---
phase: 01-session-integrity
plan: 01
type: execute
wave: 2
depends_on:
  - 01-03
files_modified:
  - apps/trainer-web/src/app/(app)/calendar/page.tsx
  - apps/trainer-web/src/app/(app)/clients/[id]/page.tsx
autonomous: true
requirements:
  - DATA-01
  - DATA-03

must_haves:
  truths:
    - "Completing a booking from the calendar deducts exactly one session even when the calendar is open in multiple tabs simultaneously"
    - "Clicking 'Use 1 Session' on the client detail page deducts exactly one session even if clicked rapidly in succession"
    - "Clicking 'Reinstate' on the client detail page reinstates exactly one session atomically — no stale component-state value is written to the DB"
    - "After any deduction or reinstatement the displayed remaining count reflects the DB-authoritative value"
  artifacts:
    - path: "apps/trainer-web/src/app/(app)/calendar/page.tsx"
      provides: "Auto-complete loop that uses atomic use_session() RPC instead of read-then-write"
      contains: "rpc('use_session'"
    - path: "apps/trainer-web/src/app/(app)/clients/[id]/page.tsx"
      provides: "Use 1 Session button using use_session() RPC, Reinstate button using release_session() RPC"
      contains: "rpc('use_session'"
  key_links:
    - from: "apps/trainer-web/src/app/(app)/calendar/page.tsx"
      to: "public.use_session()"
      via: "supabase.rpc('use_session', { p_purchase_id })"
      pattern: "rpc\\('use_session'"
    - from: "apps/trainer-web/src/app/(app)/clients/[id]/page.tsx"
      to: "public.use_session()"
      via: "supabase.rpc('use_session', { p_purchase_id })"
      pattern: "rpc\\('use_session'"
    - from: "apps/trainer-web/src/app/(app)/clients/[id]/page.tsx"
      to: "public.release_session()"
      via: "supabase.rpc('release_session', { p_purchase_id: purchase.id })"
      pattern: "rpc\\('release_session'"
---

<objective>
Replace the two browser-side non-atomic read-then-write session deduction paths with calls to the existing atomic `use_session()` DB function, and replace the non-atomic Reinstate path with a call to the new `release_session()` DB function (created in Plan 01-03).

Purpose: Eliminate the race condition where two browser tabs (or a browser tab + cron) can both read the same `sessions_used` value and both write `X+1` or `X-1`, resulting in one session counted incorrectly. The `release_session()` DB function performs the decrement as a single atomic `UPDATE ... WHERE sessions_used > 0` — the absolute value in the payload is the DB's own row, not a stale snapshot from component state.

Output: Both calendar auto-complete loop and client detail "Use 1 Session" button call `supabase.rpc('use_session', { p_purchase_id })`. The "Reinstate" button calls `supabase.rpc('release_session', { p_purchase_id: purchase.id })` and updates local state from the returned DB-authoritative `sessions_used` value.

Requires: Plan 01-03 (release_session DB function) must be deployed before this plan executes.
</objective>

<execution_context>
@C:/Users/Troy Morgan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Troy Morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@apps/trainer-web/src/app/(app)/calendar/page.tsx
@apps/trainer-web/src/app/(app)/clients/[id]/page.tsx
@supabase/migrations/0010_pricing_offers.sql
@supabase/migrations/0032_release_session_function.sql
@.planning/phases/01-session-integrity/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix calendar auto-complete loop to use atomic use_session() RPC</name>
  <files>apps/trainer-web/src/app/(app)/calendar/page.tsx</files>
  <action>
    In `apps/trainer-web/src/app/(app)/calendar/page.tsx`, locate the auto-complete loop at lines 256–276 inside `loadData()`. This loop currently does:
    1. `UPDATE bookings SET status='completed'` (fine)
    2. `SELECT sessions_used FROM client_purchases` (non-atomic read)
    3. `UPDATE client_purchases SET sessions_used = purchase.sessions_used + 1` (non-atomic write)

    Replace steps 2 and 3 with a single atomic RPC call. The revised loop body must:

    ```typescript
    for (const booking of pastBookings) {
      // Mark booking as completed
      const { error: completeError } = await supabase
        .from("bookings")
        .update({ status: "completed" })
        .eq("id", booking.id);

      if (completeError) {
        console.error("Error completing booking", booking.id, completeError);
        continue;
      }

      // Atomically deduct session using DB function (prevents double-counting across tabs)
      if (booking.purchase_id) {
        const { data: deducted, error: deductError } = await supabase
          .rpc("use_session", { p_purchase_id: booking.purchase_id });
        if (deductError) {
          console.error("Error deducting session for booking", booking.id, deductError);
        }
        // use_session() returns false if no sessions remain or pack is expired — that is acceptable
      }
    }
    ```

    Key change: remove the intermediate SELECT of `sessions_used`. The `use_session()` DB function (defined in `supabase/migrations/0010_pricing_offers.sql` lines 119–150) performs `UPDATE client_purchases SET sessions_used = sessions_used + 1` in a single atomic statement within a PL/pgSQL transaction. It returns `true` if deducted, `false` if no sessions remain.

    Do NOT restructure the surrounding `loadData()` function — fix only the loop body at lines 256–276.
  </action>
  <verify>
    <automated>cd "C:/Users/Troy Morgan/OneDrive/coach-os/apps/trainer-web" && npx tsc --noEmit 2>&1 | head -30</automated>
    <manual>Grep confirms the old pattern is gone: grep -n "sessions_used + 1" apps/trainer-web/src/app/\(app\)/calendar/page.tsx should return no results. Grep confirms new pattern: grep -n "rpc('use_session'" apps/trainer-web/src/app/\(app\)/calendar/page.tsx should return a result.</manual>
  </verify>
  <done>
    The calendar auto-complete loop at lines ~256-276 calls `supabase.rpc('use_session', { p_purchase_id: booking.purchase_id })` instead of the three-step read-then-write. TypeScript compilation passes with no new errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix client detail Use 1 Session and Reinstate buttons to use atomic RPC operations</name>
  <files>apps/trainer-web/src/app/(app)/clients/[id]/page.tsx</files>
  <action>
    In `apps/trainer-web/src/app/(app)/clients/[id]/page.tsx`, locate the two inline onClick handlers:

    **"Use 1 Session" button (lines ~2239–2257):**
    Currently does `update({ sessions_used: purchase.sessions_used + 1 })` — a non-atomic read from component state then write.

    Replace the onClick body with:
    ```typescript
    onClick={async () => {
      if (!confirm("Use 1 session from this pack?")) return;
      const { data: deducted, error } = await supabase
        .rpc("use_session", { p_purchase_id: purchase.id });
      if (error) {
        console.error("Error using session:", error);
        return;
      }
      if (!deducted) {
        alert("No sessions remaining or pack is expired.");
        return;
      }
      // Refresh local state to reflect the DB's authoritative count
      setClientPurchases(clientPurchases.map(p =>
        p.id === purchase.id
          ? { ...p, sessions_used: p.sessions_used + 1 }
          : p
      ));
    }}
    ```

    Note: The optimistic state update after the RPC succeeds is safe because `use_session()` is the write authority — the local state is only updated after the DB confirms the deduction.

    **"Reinstate" button (lines ~2259–2278):**
    Currently does `update({ sessions_used: purchase.sessions_used - 1 })` — non-atomic write using component state value. This is not concurrent-write-safe: a write from another tab between loadClient() and this click would cause the wrong absolute count to be written.

    Replace the onClick body with a call to `release_session()` (the DB function created in Plan 01-03). The function performs `UPDATE ... SET sessions_used = sessions_used - 1 WHERE id = p_purchase_id AND sessions_used > 0 RETURNING sessions_used` — the decrement and the underflow guard are both in the DB, with no stale value from component state used as the payload:

    ```typescript
    onClick={async () => {
      if (!confirm("Reinstate 1 session to this pack?")) return;
      // Atomic decrement via DB function — no stale component-state value used as payload
      const { data: newSessionsUsed, error } = await supabase
        .rpc("release_session", { p_purchase_id: purchase.id });
      if (error) {
        console.error("Error reinstating session:", error);
        return;
      }
      if (newSessionsUsed === -1) {
        // DB returned sentinel: sessions_used was already 0, no update applied
        return;
      }
      // Update local state from the DB-authoritative returned value
      setClientPurchases(clientPurchases.map(p =>
        p.id === purchase.id
          ? { ...p, sessions_used: newSessionsUsed }
          : p
      ));
    }}
    ```

    Key points:
    - `release_session()` returns `int`: the updated `sessions_used` on success, or `-1` as sentinel when `sessions_used` was already 0 (no update applied).
    - Local state is set to `newSessionsUsed` — the DB's authoritative value — not `purchase.sessions_used - 1` from component state.
    - This is symmetric with the `use_session()` path and eliminates the concurrent-write race for both deduction and reinstatement.

    Do NOT restructure the surrounding JSX — fix only the two onClick bodies.
  </action>
  <verify>
    <automated>cd "C:/Users/Troy Morgan/OneDrive/coach-os/apps/trainer-web" && npx tsc --noEmit 2>&1 | head -30</automated>
    <manual>
      1. grep -n "rpc('use_session'" apps/trainer-web/src/app/\(app\)/clients/\[id\]/page.tsx — must return a result (Use 1 Session button)
      2. grep -n "rpc('release_session'" apps/trainer-web/src/app/\(app\)/clients/\[id\]/page.tsx — must return a result (Reinstate button)
      3. grep -n "purchase.sessions_used - 1" apps/trainer-web/src/app/\(app\)/clients/\[id\]/page.tsx — must return NO results (old non-atomic pattern gone)
    </manual>
  </verify>
  <done>
    The "Use 1 Session" button calls `supabase.rpc('use_session', { p_purchase_id: purchase.id })` and only updates local state on success. The "Reinstate" button calls `supabase.rpc('release_session', { p_purchase_id: purchase.id })` and updates local state to the DB-returned `sessions_used` value. Neither button uses a stale component-state value as the update payload. TypeScript compilation passes with no new errors.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. `grep -n "purchase.sessions_used + 1" apps/trainer-web/src/app/\(app\)/calendar/page.tsx` — must return no results
2. `grep -rn "rpc('use_session'" apps/trainer-web/src/app/\(app\)/` — must return results in both calendar/page.tsx and clients/[id]/page.tsx
3. `grep -n "rpc('release_session'" apps/trainer-web/src/app/\(app\)/clients/\[id\]/page.tsx` — must return a result
4. `grep -n "purchase.sessions_used - 1" apps/trainer-web/src/app/\(app\)/clients/\[id\]/page.tsx` — must return no results (old pattern gone)
5. `cd apps/trainer-web && npx tsc --noEmit` — must pass with no new type errors
</verification>

<success_criteria>
- All browser-side session deductions in calendar and client detail go through `use_session()` DB function (RPC call)
- Reinstate uses `release_session()` DB function (RPC call) — local state is set from the DB-returned value, not from stale component state
- No read-then-write pattern for `sessions_used` arithmetic in either file
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/01-session-integrity/01-01-SUMMARY.md`
</output>
