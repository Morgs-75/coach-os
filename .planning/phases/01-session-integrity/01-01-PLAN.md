---
phase: 01-session-integrity
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/trainer-web/src/app/(app)/calendar/page.tsx
  - apps/trainer-web/src/app/(app)/clients/[id]/page.tsx
autonomous: true
requirements:
  - DATA-01
  - DATA-03

must_haves:
  truths:
    - "Completing a booking from the calendar deducts exactly one session even when the calendar is open in multiple tabs simultaneously"
    - "Clicking 'Use 1 Session' on the client detail page deducts exactly one session even if clicked rapidly in succession"
    - "Clicking 'Reinstate' on the client detail page reinstates exactly one session atomically"
    - "After any deduction or reinstatement the displayed remaining count is accurate"
  artifacts:
    - path: "apps/trainer-web/src/app/(app)/calendar/page.tsx"
      provides: "Auto-complete loop that uses atomic use_session() RPC instead of read-then-write"
      contains: "rpc('use_session'"
    - path: "apps/trainer-web/src/app/(app)/clients/[id]/page.tsx"
      provides: "Use 1 Session and Reinstate buttons that use atomic DB operations"
      contains: "rpc('use_session'"
  key_links:
    - from: "apps/trainer-web/src/app/(app)/calendar/page.tsx"
      to: "public.use_session()"
      via: "supabase.rpc('use_session', { p_purchase_id })"
      pattern: "rpc\\('use_session'"
    - from: "apps/trainer-web/src/app/(app)/clients/[id]/page.tsx"
      to: "public.use_session()"
      via: "supabase.rpc('use_session', { p_purchase_id })"
      pattern: "rpc\\('use_session'"
---

<objective>
Replace the two browser-side non-atomic read-then-write session deduction paths with calls to the existing atomic `use_session()` DB function.

Purpose: Eliminate the race condition where two browser tabs (or a browser tab + cron) can both read the same `sessions_used` value and both write `X+1`, resulting in one session counted twice.

Output: Both calendar auto-complete loop and client detail "Use 1 Session" button call `supabase.rpc('use_session', { p_purchase_id })`. The "Reinstate" button uses an atomic `UPDATE ... WHERE sessions_used > 0` guard.
</objective>

<execution_context>
@C:/Users/Troy Morgan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Troy Morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@apps/trainer-web/src/app/(app)/calendar/page.tsx
@apps/trainer-web/src/app/(app)/clients/[id]/page.tsx
@supabase/migrations/0010_pricing_offers.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix calendar auto-complete loop to use atomic use_session() RPC</name>
  <files>apps/trainer-web/src/app/(app)/calendar/page.tsx</files>
  <action>
    In `apps/trainer-web/src/app/(app)/calendar/page.tsx`, locate the auto-complete loop at lines 256–276 inside `loadData()`. This loop currently does:
    1. `UPDATE bookings SET status='completed'` (fine)
    2. `SELECT sessions_used FROM client_purchases` (non-atomic read)
    3. `UPDATE client_purchases SET sessions_used = purchase.sessions_used + 1` (non-atomic write)

    Replace steps 2 and 3 with a single atomic RPC call. The revised loop body must:

    ```typescript
    for (const booking of pastBookings) {
      // Mark booking as completed
      const { error: completeError } = await supabase
        .from("bookings")
        .update({ status: "completed" })
        .eq("id", booking.id);

      if (completeError) {
        console.error("Error completing booking", booking.id, completeError);
        continue;
      }

      // Atomically deduct session using DB function (prevents double-counting across tabs)
      if (booking.purchase_id) {
        const { data: deducted, error: deductError } = await supabase
          .rpc("use_session", { p_purchase_id: booking.purchase_id });
        if (deductError) {
          console.error("Error deducting session for booking", booking.id, deductError);
        }
        // use_session() returns false if no sessions remain or pack is expired — that is acceptable
      }
    }
    ```

    Key change: remove the intermediate SELECT of `sessions_used`. The `use_session()` DB function (defined in `supabase/migrations/0010_pricing_offers.sql` lines 119–150) performs `UPDATE client_purchases SET sessions_used = sessions_used + 1` in a single atomic statement within a PL/pgSQL transaction. It returns `true` if deducted, `false` if no sessions remain.

    Do NOT restructure the surrounding `loadData()` function — fix only the loop body at lines 256–276.
  </action>
  <verify>
    <automated>cd "C:/Users/Troy Morgan/OneDrive/coach-os/apps/trainer-web" && npx tsc --noEmit 2>&1 | head -30</automated>
    <manual>Grep confirms the old pattern is gone: grep -n "sessions_used + 1" apps/trainer-web/src/app/\(app\)/calendar/page.tsx should return no results. Grep confirms new pattern: grep -n "rpc('use_session'" apps/trainer-web/src/app/\(app\)/calendar/page.tsx should return a result.</manual>
  </verify>
  <done>
    The calendar auto-complete loop at lines ~256-276 calls `supabase.rpc('use_session', { p_purchase_id: booking.purchase_id })` instead of the three-step read-then-write. TypeScript compilation passes with no new errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix client detail Use 1 Session and Reinstate buttons to use atomic operations</name>
  <files>apps/trainer-web/src/app/(app)/clients/[id]/page.tsx</files>
  <action>
    In `apps/trainer-web/src/app/(app)/clients/[id]/page.tsx`, locate the two inline onClick handlers:

    **"Use 1 Session" button (lines ~2239–2257):**
    Currently does `update({ sessions_used: purchase.sessions_used + 1 })` — a non-atomic read from component state then write.

    Replace the onClick body with:
    ```typescript
    onClick={async () => {
      if (!confirm("Use 1 session from this pack?")) return;
      const { data: deducted, error } = await supabase
        .rpc("use_session", { p_purchase_id: purchase.id });
      if (error) {
        console.error("Error using session:", error);
        return;
      }
      if (!deducted) {
        alert("No sessions remaining or pack is expired.");
        return;
      }
      // Refresh local state to reflect the DB's authoritative count
      setClientPurchases(clientPurchases.map(p =>
        p.id === purchase.id
          ? { ...p, sessions_used: p.sessions_used + 1 }
          : p
      ));
    }}
    ```

    Note: The optimistic state update after the RPC succeeds is safe because `use_session()` is the write authority — the local state is only updated after the DB confirms the deduction.

    **"Reinstate" button (lines ~2259–2278):**
    Currently does `update({ sessions_used: purchase.sessions_used - 1 })` — non-atomic read from component state then write.

    Replace the onClick body with:
    ```typescript
    onClick={async () => {
      if (!confirm("Reinstate 1 session to this pack?")) return;
      // Atomic decrement: only decrements if sessions_used > 0 (prevents underflow)
      const { error } = await supabase
        .from("client_purchases")
        .update({ sessions_used: supabase.rpc('decrement_sessions_used_if_positive', {}) })
        .eq("id", purchase.id)
        .gt("sessions_used", 0);
    }}
    ```

    Wait — there is no `release_session()` DB function. Use a direct atomic SQL approach that does not require a new DB function:

    ```typescript
    onClick={async () => {
      if (!confirm("Reinstate 1 session to this pack?")) return;
      // Atomic: UPDATE ... WHERE sessions_used > 0 prevents underflow without a read
      const { error, count } = await supabase
        .from("client_purchases")
        .update({ sessions_used: purchase.sessions_used - 1 })
        .eq("id", purchase.id)
        .gt("sessions_used", 0);
      if (error) {
        console.error("Error reinstating session:", error);
        return;
      }
      if (count === 0) {
        // Row was not updated because sessions_used was already 0 — no action needed
        return;
      }
      setClientPurchases(clientPurchases.map(p =>
        p.id === purchase.id
          ? { ...p, sessions_used: p.sessions_used - 1 }
          : p
      ));
    }}
    ```

    IMPORTANT NOTE on Reinstate: The `.gt("sessions_used", 0)` guard makes the UPDATE conditional at the DB level — it is atomic. The `purchase.sessions_used - 1` value in the update payload is derived from component state, but the WHERE guard (`.gt("sessions_used", 0)`) ensures the update only applies if the DB row still has sessions_used > 0. This is the standard optimistic locking pattern. However, for the "Reinstate" case there is no existing DB function, so this guarded UPDATE is the correct atomic approach.

    Also update the `.select()` call to include `{ count: "exact" }` option to receive the count:
    ```typescript
    const { error, count } = await supabase
      .from("client_purchases")
      .update({ sessions_used: purchase.sessions_used - 1 }, { count: "exact" })
      .eq("id", purchase.id)
      .gt("sessions_used", 0);
    ```

    Do NOT restructure the surrounding JSX — fix only the two onClick bodies.
  </action>
  <verify>
    <automated>cd "C:/Users/Troy Morgan/OneDrive/coach-os/apps/trainer-web" && npx tsc --noEmit 2>&1 | head -30</automated>
    <manual>Grep confirms: grep -n "sessions_used: purchase.sessions_used" apps/trainer-web/src/app/\(app\)/clients/\[id\]/page.tsx should show only the Reinstate guarded update (with .gt guard), not the old unguarded Use 1 Session pattern. Grep confirms: grep -n "rpc('use_session'" apps/trainer-web/src/app/\(app\)/clients/\[id\]/page.tsx returns a result.</manual>
  </verify>
  <done>
    The "Use 1 Session" button calls `supabase.rpc('use_session', { p_purchase_id: purchase.id })` and only updates local state on success. The "Reinstate" button uses `.gt("sessions_used", 0)` WHERE guard making it conditionally atomic. TypeScript compilation passes with no new errors.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. `grep -n "purchase.sessions_used + 1" apps/trainer-web/src/app/\(app\)/calendar/page.tsx` — must return no results
2. `grep -rn "rpc('use_session'" apps/trainer-web/src/app/\(app\)/` — must return results in both calendar/page.tsx and clients/[id]/page.tsx
3. `cd apps/trainer-web && npx tsc --noEmit` — must pass with no new type errors
4. No intermediate `SELECT sessions_used` in calendar auto-complete loop — `grep -n "\.from(\"client_purchases\").*\.select(" apps/trainer-web/src/app/\(app\)/calendar/page.tsx` in the loop context should be gone
</verification>

<success_criteria>
- All browser-side session deductions in calendar and client detail go through `use_session()` DB function (RPC call)
- No read-then-write pattern for `sessions_used + 1` in calendar/page.tsx or clients/[id]/page.tsx
- Reinstate uses a guarded update (`.gt("sessions_used", 0)`) rather than unguarded state-based write
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/01-session-integrity/01-01-SUMMARY.md`
</output>
