---
phase: 07-plan-builder-ai-generation
plan: 03
type: execute
wave: 3
depends_on:
  - 07-02
files_modified:
  - apps/trainer-web/src/app/api/nutrition/plans/[planId]/generate/route.ts
  - apps/trainer-web/src/app/(app)/nutrition/[planId]/PlanBuilderClient.tsx
autonomous: true
requirements:
  - NUTR-10

must_haves:
  truths:
    - "POST /api/nutrition/plans/[planId]/generate accepts goal, calorie_target, macro_split, and dietary_restrictions from request body"
    - "The endpoint calls Claude claude-sonnet-4-6 via the Anthropic Messages API using ANTHROPIC_API_KEY"
    - "Claude returns a 7-day JSON plan containing day_number, meals (with meal_type + title), and components (food_item_id from AFCD + qty_g)"
    - "The endpoint inserts the generated days, meals, and components into the DB, clearing any existing days first"
    - "All food_item_id values in the Claude response are validated against the food_items table before insertion; invalid IDs are skipped"
    - "'Generate with AI' button in PlanBuilderClient opens a modal with goal, calorie target, macro split, and restrictions inputs"
    - "On success the plan reloads and shows the generated days and meals"
    - "If ANTHROPIC_API_KEY is missing the endpoint returns 500 with a clear error message"
  artifacts:
    - path: "apps/trainer-web/src/app/api/nutrition/plans/[planId]/generate/route.ts"
      provides: "POST AI generation endpoint — clears plan days, generates 7-day plan, inserts DB rows"
  key_links:
    - from: "apps/trainer-web/src/app/api/nutrition/plans/[planId]/generate/route.ts"
      to: "https://api.anthropic.com/v1/messages"
      via: "fetch with x-api-key header"
      pattern: "anthropic.com/v1/messages"
    - from: "apps/trainer-web/src/app/api/nutrition/plans/[planId]/generate/route.ts"
      to: "food_items table"
      via: "Supabase query to validate food_item_id values from Claude response"
      pattern: "supabase.from.*food_items"
    - from: "PlanBuilderClient.tsx (GenerateModal)"
      to: "/api/nutrition/plans/[planId]/generate"
      via: "POST on submit"
      pattern: "fetch.*generate.*POST"
---

<objective>
Build the AI plan generation endpoint and the "Generate with AI" UI flow.

Purpose: Coach provides a few inputs (goal, calories, macro split, restrictions) and Claude generates a complete 7-day meal plan using real AFCD food IDs. The result fills the plan builder — coach can then edit any component manually.
Output: POST /api/nutrition/plans/[planId]/generate API + GenerateModal component in PlanBuilderClient.tsx.
</objective>

<execution_context>
@C:/Users/Troy Morgan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Troy Morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-plan-builder-ai-generation/07-02-SUMMARY.md

<interfaces>
<!-- AI call pattern (from apps/trainer-web/src/app/api/marketing/templates/generate/route.ts) -->
```typescript
const anthropicKey = process.env.ANTHROPIC_API_KEY;
if (!anthropicKey) return NextResponse.json({ error: "AI not configured" }, { status: 500 });

const response = await fetch("https://api.anthropic.com/v1/messages", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
    "x-api-key": anthropicKey,
    "anthropic-version": "2023-06-01",
  },
  body: JSON.stringify({
    model: "claude-sonnet-4-6",   // <-- use this model for Phase 7
    max_tokens: 8192,
    messages: [{ role: "user", content: prompt }],
  }),
});
const data = await response.json();
const responseText = data.content[0].text;
```

<!-- food_items table — used to validate IDs Claude returns -->
<!-- food_items columns: id (uuid), afcd_food_id (text), food_name (text), food_group (text), energy_kcal, protein_g, fat_g, carb_g, fibre_g -->
<!-- 1,588 rows seeded from AFCD Release 3 -->

<!-- Generation prompt strategy -->
<!--
  The prompt must:
  1. Tell Claude to pick from AFCD food_items already in the DB
  2. Provide a representative sample of AFCD food IDs + names (so Claude can reference real UUIDs)
  3. Ask for structured JSON output
  4. Include client inputs: goal, calorie_target, macro_split (protein%/carb%/fat%), dietary_restrictions

  Sample fetch approach:
  - Query food_items grouped by food_group ORDER BY RANDOM() LIMIT 200 to give Claude a diverse pool
  - Pass as: "Available foods (id | name | group):\n<list>"
  - Instruct Claude: "Use ONLY food_item_ids from the list above. Do not invent IDs."
-->

<!-- Expected Claude JSON response shape -->
<!--
{
  "days": [
    {
      "day_number": 1,
      "meals": [
        {
          "meal_type": "breakfast",
          "title": "High-protein oats",
          "components": [
            { "food_item_id": "<uuid>", "qty_g": 80 },
            { "food_item_id": "<uuid>", "qty_g": 200 }
          ]
        }
      ]
    },
    ... (days 2-7)
  ]
}
-->

<!-- DB insertion order: days → meals → components (must respect FK chain) -->
<!-- Clear existing days first (CASCADE deletes meals + components automatically) -->
<!-- Use meal_plan_days UNIQUE(plan_id, day_number) — insert in order, no conflict if cleared first -->

<!-- meal_type valid values: breakfast, morning_snack, lunch, afternoon_snack, dinner, evening_snack, other -->
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create POST /api/nutrition/plans/[planId]/generate endpoint</name>
  <files>
    apps/trainer-web/src/app/api/nutrition/plans/[planId]/generate/route.ts
  </files>
  <action>
Create `apps/trainer-web/src/app/api/nutrition/plans/[planId]/generate/route.ts`.

The endpoint performs these steps:
1. Authenticate + verify plan ownership
2. Fetch a diverse sample of food_items (up to 250 rows across food groups) for the prompt
3. Build the Claude prompt with the food sample + coach inputs
4. Call Claude claude-sonnet-4-6 via Anthropic Messages API
5. Parse Claude's JSON response
6. Validate all food_item_ids against the food_items table
7. Clear existing plan days (CASCADE removes meals + components)
8. Insert days → meals → components
9. Return `{ success: true, days_created: N }`

```typescript
import { NextResponse } from "next/server";
import { createClient } from "@/lib/supabase/server";

async function getOrgAndUser(supabase: Awaited<ReturnType<typeof createClient>>) {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return { orgId: null, userId: null };
  const { data: membership } = await supabase
    .from("org_members")
    .select("org_id")
    .eq("user_id", user.id)
    .single();
  return { orgId: membership?.org_id ?? null, userId: user.id };
}

interface GenerateBody {
  goal?: string;
  calorie_target?: number;
  macro_split?: { protein_pct: number; carb_pct: number; fat_pct: number };
  dietary_restrictions?: string;
}

const VALID_MEAL_TYPES = new Set([
  "breakfast", "morning_snack", "lunch", "afternoon_snack",
  "dinner", "evening_snack", "other",
]);

export async function POST(
  request: Request,
  { params }: { params: Promise<{ planId: string }> }
) {
  try {
    const { planId } = await params;
    const supabase = await createClient();
    const { orgId } = await getOrgAndUser(supabase);
    if (!orgId) return NextResponse.json({ error: "Unauthorized" }, { status: 401 });

    // Verify plan belongs to org
    const { data: plan } = await supabase
      .from("meal_plans")
      .select("id, name, client_id")
      .eq("id", planId)
      .eq("org_id", orgId)
      .single();
    if (!plan) return NextResponse.json({ error: "Plan not found" }, { status: 404 });

    const anthropicKey = process.env.ANTHROPIC_API_KEY;
    if (!anthropicKey) {
      return NextResponse.json({ error: "AI not configured — ANTHROPIC_API_KEY is missing" }, { status: 500 });
    }

    // Parse request body
    const body: GenerateBody = await request.json().catch(() => ({}));
    const goal = body.goal?.trim() || "general health and balanced nutrition";
    const calorieTarget = body.calorie_target ?? 2000;
    const macroPct = body.macro_split ?? { protein_pct: 30, carb_pct: 45, fat_pct: 25 };
    const restrictions = body.dietary_restrictions?.trim() || "none";

    // Fetch a diverse sample of food_items for the prompt
    // Get up to 250 foods ordered by food_group then food_name for variety
    const { data: foodSample } = await supabase
      .from("food_items")
      .select("id, food_name, food_group, energy_kcal, protein_g, carb_g, fat_g")
      .order("food_group", { ascending: true })
      .order("food_name", { ascending: true })
      .limit(250);

    const foodList = (foodSample ?? [])
      .map((f) => `${f.id} | ${f.food_name} | ${f.food_group ?? "General"} | kcal/100g: ${f.energy_kcal ?? "?"} | P: ${f.protein_g ?? "?"} | C: ${f.carb_g ?? "?"} | F: ${f.fat_g ?? "?"}`)
      .join("\n");

    const prompt = `You are a sports nutrition expert. Generate a 7-day meal plan for a personal training client.

CLIENT GOAL: ${goal}
DAILY CALORIE TARGET: ${calorieTarget} kcal
MACRO SPLIT: Protein ${macroPct.protein_pct}% / Carbs ${macroPct.carb_pct}% / Fat ${macroPct.fat_pct}%
DIETARY RESTRICTIONS: ${restrictions}

AVAILABLE FOODS (id | name | group | kcal/100g | protein_g | carb_g | fat_g):
${foodList}

INSTRUCTIONS:
- Create exactly 7 days (day_number 1 through 7).
- Each day must have 3–5 meals using these meal_type values only: breakfast, morning_snack, lunch, afternoon_snack, dinner, evening_snack, other.
- Each meal should have 2–5 food components.
- Use ONLY food_item_ids from the list above — do NOT invent UUIDs.
- Set qty_g to a realistic serving size (e.g. oats: 80g, chicken breast: 150g, milk: 200g).
- Aim for each day's total calories to be within 10% of the calorie target.
- Vary foods across days — do not repeat the same meal every day.
- Respect dietary restrictions strictly.

Respond with ONLY valid JSON in this exact structure — no commentary, no markdown:
{
  "days": [
    {
      "day_number": 1,
      "meals": [
        {
          "meal_type": "breakfast",
          "title": "optional descriptive title",
          "components": [
            { "food_item_id": "<uuid from list>", "qty_g": 80 }
          ]
        }
      ]
    }
  ]
}`;

    // Call Claude
    const aiResponse = await fetch("https://api.anthropic.com/v1/messages", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": anthropicKey,
        "anthropic-version": "2023-06-01",
      },
      body: JSON.stringify({
        model: "claude-sonnet-4-6",
        max_tokens: 8192,
        messages: [{ role: "user", content: prompt }],
      }),
    });

    if (!aiResponse.ok) {
      const errText = await aiResponse.text();
      console.error("Anthropic API error:", errText);
      return NextResponse.json({ error: "AI generation failed" }, { status: 500 });
    }

    const aiData = await aiResponse.json();
    const responseText: string = aiData.content?.[0]?.text ?? "";

    // Extract JSON from response (strip any accidental markdown fences)
    const jsonMatch = responseText.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      console.error("No JSON in Claude response:", responseText.slice(0, 500));
      return NextResponse.json({ error: "AI returned invalid response" }, { status: 500 });
    }

    let generated: { days: Array<{ day_number: number; meals: Array<{ meal_type: string; title?: string; components: Array<{ food_item_id: string; qty_g: number }> }> }> };
    try {
      generated = JSON.parse(jsonMatch[0]);
    } catch {
      return NextResponse.json({ error: "Failed to parse AI response as JSON" }, { status: 500 });
    }

    if (!generated.days || !Array.isArray(generated.days)) {
      return NextResponse.json({ error: "AI response missing days array" }, { status: 500 });
    }

    // Collect all food_item_ids Claude used and validate them
    const allFoodIds = new Set<string>();
    for (const day of generated.days) {
      for (const meal of day.meals ?? []) {
        for (const comp of meal.components ?? []) {
          if (comp.food_item_id) allFoodIds.add(comp.food_item_id);
        }
      }
    }

    const validFoodIds = new Set<string>();
    if (allFoodIds.size > 0) {
      const { data: validFoods } = await supabase
        .from("food_items")
        .select("id")
        .in("id", Array.from(allFoodIds));
      (validFoods ?? []).forEach((f) => validFoodIds.add(f.id));
    }

    // Clear existing days (CASCADE removes meals + components)
    await supabase.from("meal_plan_days").delete().eq("plan_id", planId);

    // Insert days → meals → components
    let daysCreated = 0;
    for (const day of generated.days) {
      if (!day.day_number || !Array.isArray(day.meals)) continue;

      const { data: insertedDay, error: dayError } = await supabase
        .from("meal_plan_days")
        .insert({ plan_id: planId, day_number: day.day_number })
        .select()
        .single();

      if (dayError || !insertedDay) {
        console.error("Failed to insert day:", dayError);
        continue;
      }
      daysCreated++;

      let mealSortOrder = 0;
      for (const meal of day.meals) {
        const mealType = VALID_MEAL_TYPES.has(meal.meal_type) ? meal.meal_type : "other";

        const { data: insertedMeal, error: mealError } = await supabase
          .from("meal_plan_meals")
          .insert({
            day_id: insertedDay.id,
            meal_type: mealType,
            title: meal.title ?? null,
            sort_order: mealSortOrder++,
          })
          .select()
          .single();

        if (mealError || !insertedMeal) {
          console.error("Failed to insert meal:", mealError);
          continue;
        }

        let compSortOrder = 0;
        for (const comp of meal.components ?? []) {
          // Skip components with invalid food IDs
          if (!validFoodIds.has(comp.food_item_id)) continue;
          const qty = Math.max(1, Number(comp.qty_g) || 100);

          await supabase.from("meal_plan_components").insert({
            meal_id: insertedMeal.id,
            food_item_id: comp.food_item_id,
            qty_g: qty,
            sort_order: compSortOrder++,
          });
        }
      }
    }

    // Update plan updated_at
    await supabase
      .from("meal_plans")
      .update({ updated_at: new Date().toISOString() })
      .eq("id", planId);

    return NextResponse.json({ success: true, days_created: daysCreated });
  } catch (error) {
    console.error("Generation error:", error);
    return NextResponse.json({ error: "Generation failed", details: String(error) }, { status: 500 });
  }
}
```
  </action>
  <verify>
    <automated>node -e "
const fs = require('fs');
const f = 'apps/trainer-web/src/app/api/nutrition/plans/[planId]/generate/route.ts';
if (!fs.existsSync(f)) throw new Error('Missing generate route');
const s = fs.readFileSync(f, 'utf8');
['claude-sonnet-4-6','anthropic.com/v1/messages','ANTHROPIC_API_KEY','food_items','meal_plan_days','meal_plan_meals','meal_plan_components','validFoodIds','days_created','VALID_MEAL_TYPES'].forEach(k => {
  if (!s.includes(k)) throw new Error('Generate route missing: ' + k);
});
console.log('Generate route OK');
" 2>&1</automated>
  </verify>
  <done>POST /api/nutrition/plans/[planId]/generate exists. Fetches 250 AFCD food samples, prompts claude-sonnet-4-6 with goal/calories/macros/restrictions, validates food_item_ids, clears existing days, and inserts 7 days of meals and components. Returns { success: true, days_created: N }.</done>
</task>

<task type="auto">
  <name>Task 2: Add GenerateModal and Generate with AI button to PlanBuilderClient</name>
  <files>
    apps/trainer-web/src/app/(app)/nutrition/[planId]/PlanBuilderClient.tsx
  </files>
  <action>
Add the GenerateModal component and "Generate with AI" button to `PlanBuilderClient.tsx`.

**Additions to PlanBuilderClient state (top level):**
```typescript
const [showGenerateModal, setShowGenerateModal] = useState(false);
```

**Add "Generate with AI" button to the plan header** (next to the status badge, in the flex row with plan name). Add it alongside the existing status badge in the header:
```tsx
<button
  onClick={() => setShowGenerateModal(true)}
  className="px-3 py-1.5 rounded-lg text-sm font-medium border border-brand-600 text-brand-600 dark:text-brand-400 dark:border-brand-500 hover:bg-brand-50 dark:hover:bg-brand-900/20 transition-colors"
>
  Generate with AI
</button>
```

**Add GenerateModal render** at the bottom of the PlanBuilderClient return, before the closing `</div>`:
```tsx
{showGenerateModal && (
  <GenerateModal
    planId={planId}
    onClose={() => setShowGenerateModal(false)}
    onGenerated={() => {
      setShowGenerateModal(false);
      // Reload plan from API to get generated days/meals/components
      setLoading(true);
      setSelectedDayId(null);
      fetch(`/api/nutrition/plans/${planId}`)
        .then((r) => r.json())
        .then((data) => {
          setPlan(data.plan);
          if (data.plan.days?.length > 0) {
            setSelectedDayId(data.plan.days[0].id);
          }
        })
        .finally(() => setLoading(false));
    }}
  />
)}
```

---

**GenerateModal component** (add to the bottom of the file, after MealCard):

```typescript
function GenerateModal({
  planId,
  onClose,
  onGenerated,
}: {
  planId: string;
  onClose: () => void;
  onGenerated: () => void;
}) {
  const [goal, setGoal] = useState("weight loss");
  const [calorieTarget, setCalorieTarget] = useState(2000);
  const [proteinPct, setProteinPct] = useState(30);
  const [carbPct, setCarbPct] = useState(45);
  const [fatPct, setFatPct] = useState(25);
  const [restrictions, setRestrictions] = useState("");
  const [generating, setGenerating] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Auto-balance macros so they sum to 100
  const macroSum = proteinPct + carbPct + fatPct;

  const inputClass = "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-brand-500 dark:bg-gray-800 dark:text-gray-100";

  async function handleGenerate(e: React.FormEvent) {
    e.preventDefault();
    if (macroSum !== 100) {
      setError(`Macros must sum to 100% (currently ${macroSum}%)`);
      return;
    }
    setGenerating(true);
    setError(null);
    try {
      const res = await fetch(`/api/nutrition/plans/${planId}/generate`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          goal,
          calorie_target: calorieTarget,
          macro_split: { protein_pct: proteinPct, carb_pct: carbPct, fat_pct: fatPct },
          dietary_restrictions: restrictions || null,
        }),
      });
      if (res.ok) {
        onGenerated();
      } else {
        const data = await res.json();
        setError(data.error ?? "Generation failed");
      }
    } catch {
      setError("Generation failed");
    } finally {
      setGenerating(false);
    }
  }

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className="bg-white dark:bg-gray-900 rounded-xl p-6 w-full max-w-md shadow-xl">
        <div className="flex items-center justify-between mb-5">
          <div>
            <h2 className="text-lg font-semibold text-gray-900 dark:text-gray-100">
              Generate with AI
            </h2>
            <p className="text-xs text-gray-500 dark:text-gray-400 mt-0.5">
              Claude will create a 7-day meal plan using AFCD foods.
              Any existing days will be replaced.
            </p>
          </div>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-200"
          >
            ✕
          </button>
        </div>

        <form onSubmit={handleGenerate} className="space-y-4">
          {/* Goal */}
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Client Goal
            </label>
            <input
              type="text"
              value={goal}
              onChange={(e) => setGoal(e.target.value)}
              placeholder="e.g. weight loss, muscle gain, general health"
              className={inputClass}
            />
          </div>

          {/* Calorie target */}
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Daily Calorie Target (kcal)
            </label>
            <input
              type="number"
              min="500"
              max="6000"
              step="50"
              value={calorieTarget}
              onChange={(e) => setCalorieTarget(Number(e.target.value))}
              className={inputClass}
            />
          </div>

          {/* Macro split */}
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Macro Split (must total 100%)
            </label>
            <div className="grid grid-cols-3 gap-2">
              <div>
                <label className="block text-xs text-gray-500 dark:text-gray-400 mb-0.5">Protein %</label>
                <input
                  type="number"
                  min="0"
                  max="100"
                  value={proteinPct}
                  onChange={(e) => setProteinPct(Number(e.target.value))}
                  className={inputClass}
                />
              </div>
              <div>
                <label className="block text-xs text-gray-500 dark:text-gray-400 mb-0.5">Carbs %</label>
                <input
                  type="number"
                  min="0"
                  max="100"
                  value={carbPct}
                  onChange={(e) => setCarbPct(Number(e.target.value))}
                  className={inputClass}
                />
              </div>
              <div>
                <label className="block text-xs text-gray-500 dark:text-gray-400 mb-0.5">Fat %</label>
                <input
                  type="number"
                  min="0"
                  max="100"
                  value={fatPct}
                  onChange={(e) => setFatPct(Number(e.target.value))}
                  className={inputClass}
                />
              </div>
            </div>
            <p className={`text-xs mt-1 ${macroSum === 100 ? "text-green-600" : "text-amber-600"}`}>
              Total: {macroSum}%{macroSum !== 100 ? " (must equal 100)" : " ✓"}
            </p>
          </div>

          {/* Dietary restrictions */}
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Dietary Restrictions
            </label>
            <input
              type="text"
              value={restrictions}
              onChange={(e) => setRestrictions(e.target.value)}
              placeholder="e.g. gluten-free, vegetarian, no dairy (optional)"
              className={inputClass}
            />
          </div>

          {error && (
            <p className="text-sm text-red-600 dark:text-red-400">{error}</p>
          )}

          {generating && (
            <div className="flex items-center gap-2 text-sm text-gray-500 dark:text-gray-400">
              <span className="w-4 h-4 border-2 border-brand-500 border-t-transparent rounded-full animate-spin flex-shrink-0" />
              Generating 7-day plan… this may take 20–40 seconds.
            </div>
          )}

          <div className="flex justify-end gap-3 pt-1">
            <button
              type="button"
              onClick={onClose}
              disabled={generating}
              className="px-4 py-2 text-sm text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100 disabled:opacity-50 transition-colors"
            >
              Cancel
            </button>
            <button
              type="submit"
              disabled={generating || macroSum !== 100}
              className="bg-brand-600 text-white px-4 py-2 rounded-lg text-sm font-medium hover:bg-brand-700 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2 transition-colors"
            >
              Generate Plan
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}
```
  </action>
  <verify>
    <automated>node -e "
const fs = require('fs');
const pb = fs.readFileSync('apps/trainer-web/src/app/(app)/nutrition/[planId]/PlanBuilderClient.tsx', 'utf8');
['GenerateModal','showGenerateModal','Generate with AI','calorie_target','macro_split','generate.*POST|POST.*generate','onGenerated','generating'].forEach(k => {
  const re = new RegExp(k);
  if (!re.test(pb)) throw new Error('PlanBuilderClient missing: ' + k);
});
console.log('GenerateModal wired OK');
" 2>&1</automated>
  </verify>
  <done>PlanBuilderClient.tsx has "Generate with AI" button in plan header and GenerateModal with goal, calorie target, macro split (3 inputs summing to 100%), dietary restrictions. On success reloads plan from API and auto-selects Day 1. Generating spinner shown with estimated time message.</done>
</task>

</tasks>

<verification>
- Click "Generate with AI" → modal opens with default values (goal: weight loss, 2000 kcal, 30/45/25 macro split)
- Change macro values so they don't sum to 100 → "Generate Plan" button disabled and warning shows
- Fix macros to 100% → submit → spinner appears with "Generating 7-day plan… 20–40 seconds" message
- After 20–40 seconds, modal closes and plan reloads with Day 1 through Day 7 in the sidebar
- Each day shows 3–5 meal cards with food components and calculated macros
- Coach can click any day, see meals, and manually edit component quantities
- If ANTHROPIC_API_KEY is missing, returns "AI not configured" error in modal
</verification>

<success_criteria>
Coach clicks "Generate with AI", provides goal + calorie target + macro split, and within 40 seconds the plan builder populates with 7 days of AFCD-matched meals and auto-calculated macros. Coach can then edit any component.
</success_criteria>

<output>
After completion, create `.planning/phases/07-plan-builder-ai-generation/07-03-SUMMARY.md`
</output>
