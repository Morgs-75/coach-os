---
phase: 10-async-ai-generation
plan: 02
type: execute
wave: 2
depends_on:
  - 10-01
files_modified:
  - apps/trainer-web/src/app/api/nutrition/plans/[planId]/generate/route.ts
  - apps/trainer-web/src/app/api/nutrition/plans/[planId]/generate/start/route.ts
  - apps/trainer-web/src/app/api/nutrition/plans/[planId]/generate/run/route.ts
  - apps/trainer-web/src/app/api/nutrition/plans/[planId]/generate/status/route.ts
autonomous: true
requirements:
  - ASYNC-02
must_haves:
  truths:
    - "POST .../generate/start responds in under 200ms (sets status='generating', returns immediately)"
    - "POST .../generate/run is idempotent — returns 200 immediately if status is already 'complete' or still 'generating' from another call"
    - "POST .../generate/run does the full AI work (two-pass, calorie scaling, food dedup, extractRootJson) preserved verbatim"
    - "GET .../generate/status returns { generation_status, generation_error } for polling"
    - "On error, /run sets generation_status='error' and generation_error to a descriptive message"
  artifacts:
    - path: "apps/trainer-web/src/app/api/nutrition/plans/[planId]/generate/start/route.ts"
      provides: "POST endpoint that sets generation_status='generating' and returns fast"
      exports: ["POST"]
    - path: "apps/trainer-web/src/app/api/nutrition/plans/[planId]/generate/run/route.ts"
      provides: "POST endpoint that runs AI generation, idempotent on status check"
      exports: ["POST"]
    - path: "apps/trainer-web/src/app/api/nutrition/plans/[planId]/generate/status/route.ts"
      provides: "GET endpoint returning current generation_status + generation_error"
      exports: ["GET"]
  key_links:
    - from: "apps/trainer-web/src/app/api/nutrition/plans/[planId]/generate/run/route.ts"
      to: "meal_plans.generation_status"
      via: "supabase UPDATE generation_status='complete'/'error'"
      pattern: "generation_status"
    - from: "apps/trainer-web/src/app/api/nutrition/plans/[planId]/generate/status/route.ts"
      to: "meal_plans"
      via: "SELECT generation_status, generation_error WHERE id=planId"
      pattern: "generation_status"
---

<objective>
Split the existing monolithic `POST /api/nutrition/plans/[planId]/generate` into three sub-routes:
- `POST .../generate/start` — fast response (~100ms), sets generation_status='generating'
- `POST .../generate/run` — does all AI work (up to 60s), updates status on completion, idempotent
- `GET .../generate/status` — polling endpoint, returns current status + error

The existing monolithic `route.ts` is converted to a 404 stub or deleted (the sub-routes take over).
All AI logic from the original route (two-pass Claude calls, calorie scaling, food dedup, extractRootJson, group-based food queries) moves verbatim into /run.

Purpose: Netlify's 26s function timeout kills generation of multi-day plans. Splitting into fire-and-forget + poll pattern works within the timeout constraint.
Output: Three new route files, existing route.ts replaced with stub/redirect notice.
</objective>

<execution_context>
@C:/Users/Troy Morgan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Troy Morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-async-ai-generation/10-CONTEXT.md
@apps/trainer-web/src/app/api/nutrition/plans/[planId]/generate/route.ts

<interfaces>
<!-- Existing generate route — key types and helpers that MUST be preserved verbatim in /run -->

From apps/trainer-web/src/app/api/nutrition/plans/[planId]/generate/route.ts:

```typescript
// Model selection (preserve this logic in /run)
const model = requestedDays <= 3 ? "claude-sonnet-4-6" : "claude-haiku-4-5-20251001";
const maxTokens = requestedDays <= 1 ? 2048 : requestedDays <= 4 ? 4096 : 8192;

// Request body shape (same body accepted by /start and forwarded to /run)
interface GenerateBody {
  intake_data?: Record<string, any>;
  plan_length_days?: number;
  // Legacy simple path
  goal?: string;
  calorie_target?: number;
  macro_split?: { protein_pct: number; carb_pct: number; fat_pct: number };
  dietary_restrictions?: string;
}

// extractRootJson — brace-depth scanner, MUST be preserved verbatim
function extractRootJson(text: string): string | null {
  const start = text.indexOf('{');
  if (start === -1) return null;
  let depth = 0;
  for (let i = start; i < text.length; i++) {
    if (text[i] === '{') depth++;
    else if (text[i] === '}') { depth--; if (depth === 0) return text.slice(start, i + 1); }
  }
  return null;
}

// Two-pass: FIRST_PASS_MAX = 5 (days 1-5 first, days 6+ second)
// Calorie scaler: scale = targetKcal / actualKcal, apply if |scale-1| > 0.03
// Food dedup: usedIds + usedFamilies per day, drop emptied meals
```

New DB columns (from migration 0046):
```sql
meal_plans.generation_status text DEFAULT 'idle'  -- idle | generating | complete | error
meal_plans.generation_error  text                  -- null or error message
```

Next.js 15 dynamic params pattern (used throughout this codebase):
```typescript
export async function POST(
  request: Request,
  { params }: { params: Promise<{ planId: string }> }
) {
  const { planId } = await params;
  ...
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create /generate/start — fast status setter</name>
  <files>apps/trainer-web/src/app/api/nutrition/plans/[planId]/generate/start/route.ts</files>
  <action>
Create `apps/trainer-web/src/app/api/nutrition/plans/[planId]/generate/start/route.ts`:

```typescript
import { NextResponse } from "next/server";
import { createClient } from "@/lib/supabase/server";

async function getOrgId(supabase: Awaited<ReturnType<typeof createClient>>) {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return null;
  const { data: membership } = await supabase
    .from("org_members")
    .select("org_id")
    .eq("user_id", user.id)
    .single();
  return membership?.org_id ?? null;
}

export async function POST(
  _request: Request,
  { params }: { params: Promise<{ planId: string }> }
) {
  const { planId } = await params;
  const supabase = await createClient();
  const orgId = await getOrgId(supabase);
  if (!orgId) return NextResponse.json({ error: "Unauthorized" }, { status: 401 });

  // Verify plan belongs to org
  const { data: plan } = await supabase
    .from("meal_plans")
    .select("id")
    .eq("id", planId)
    .eq("org_id", orgId)
    .single();
  if (!plan) return NextResponse.json({ error: "Plan not found" }, { status: 404 });

  // Reset any previous error and set status to generating
  const { error: updateError } = await supabase
    .from("meal_plans")
    .update({ generation_status: "generating", generation_error: null })
    .eq("id", planId);

  if (updateError) {
    return NextResponse.json({ error: "Failed to set generation status" }, { status: 500 });
  }

  return NextResponse.json({ status: "generating" });
}
```

This route has no `maxDuration` — it must complete well within the default timeout (~100ms for a simple UPDATE).
  </action>
  <verify>
    <automated>cd "C:/Users/Troy Morgan/OneDrive/coach-os/apps/trainer-web" && npx tsc --noEmit --project tsconfig.json 2>&1 | grep -i "generate/start" || echo "No TS errors in start route"</automated>
  </verify>
  <done>
    - File exists at the correct path
    - No TypeScript errors
    - Route exports a POST function accepting planId dynamic param
  </done>
</task>

<task type="auto">
  <name>Task 2: Create /generate/status — polling endpoint</name>
  <files>apps/trainer-web/src/app/api/nutrition/plans/[planId]/generate/status/route.ts</files>
  <action>
Create `apps/trainer-web/src/app/api/nutrition/plans/[planId]/generate/status/route.ts`:

```typescript
import { NextResponse } from "next/server";
import { createClient } from "@/lib/supabase/server";

async function getOrgId(supabase: Awaited<ReturnType<typeof createClient>>) {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return null;
  const { data: membership } = await supabase
    .from("org_members")
    .select("org_id")
    .eq("user_id", user.id)
    .single();
  return membership?.org_id ?? null;
}

export async function GET(
  _request: Request,
  { params }: { params: Promise<{ planId: string }> }
) {
  const { planId } = await params;
  const supabase = await createClient();
  const orgId = await getOrgId(supabase);
  if (!orgId) return NextResponse.json({ error: "Unauthorized" }, { status: 401 });

  const { data: plan, error } = await supabase
    .from("meal_plans")
    .select("generation_status, generation_error")
    .eq("id", planId)
    .eq("org_id", orgId)
    .single();

  if (error || !plan) {
    return NextResponse.json({ error: "Plan not found" }, { status: 404 });
  }

  return NextResponse.json({
    generation_status: plan.generation_status,
    generation_error: plan.generation_error ?? null,
  });
}
```
  </action>
  <verify>
    <automated>cd "C:/Users/Troy Morgan/OneDrive/coach-os/apps/trainer-web" && npx tsc --noEmit --project tsconfig.json 2>&1 | grep -i "generate/status" || echo "No TS errors in status route"</automated>
  </verify>
  <done>
    - File exists at the correct path
    - No TypeScript errors
    - Route exports a GET function returning { generation_status, generation_error }
  </done>
</task>

<task type="auto">
  <name>Task 3: Create /generate/run — AI work endpoint + stub old route</name>
  <files>
    apps/trainer-web/src/app/api/nutrition/plans/[planId]/generate/run/route.ts
    apps/trainer-web/src/app/api/nutrition/plans/[planId]/generate/route.ts
  </files>
  <action>
**Part A: Create /generate/run**

Create `apps/trainer-web/src/app/api/nutrition/plans/[planId]/generate/run/route.ts`.

This file is a near-verbatim copy of the original `route.ts` with these changes:
1. `export const maxDuration = 60;` is kept
2. The `getOrgAndUser` helper is kept but only `orgId` is needed (userId not required here since /start already verified ownership)
3. At the very start of the POST handler, BEFORE any AI work, add an idempotency guard:
   ```typescript
   const { data: planRow } = await supabase
     .from("meal_plans")
     .select("generation_status")
     .eq("id", planId)
     .eq("org_id", orgId)
     .single();
   if (!planRow) return NextResponse.json({ error: "Plan not found" }, { status: 404 });
   // Idempotency: only run if status is 'generating' (set by /start)
   if (planRow.generation_status !== "generating") {
     return NextResponse.json({ status: planRow.generation_status });
   }
   ```
4. Replace the final `return NextResponse.json({ success: true, days_created: daysCreated });` with:
   ```typescript
   await supabase
     .from("meal_plans")
     .update({ generation_status: "complete" })
     .eq("id", planId);
   return NextResponse.json({ success: true, days_created: daysCreated });
   ```
5. In the outer catch block, before returning the error response, add:
   ```typescript
   await supabase
     .from("meal_plans")
     .update({ generation_status: "error", generation_error: String(error) })
     .eq("id", planId);
   ```
   Also add the same update in the inner try/catch where `callClaude` is first called (first-pass error):
   ```typescript
   // In the first-pass catch block:
   await supabase.from("meal_plans").update({
     generation_status: "error",
     generation_error: String(err),
   }).eq("id", planId);
   return NextResponse.json({ error: String(err) }, { status: 500 });
   ```
6. The `updatePayload` at the end already updates `updated_at` and `intake_data` — keep this, just add the `generation_status: "complete"` update as a separate call before the final return (or merge into updatePayload).

All other code (buildRichPrompt, buildSimplePrompt, extractRootJson, TARGET_GROUPS, FAMILY_CAPS, callClaude, two-pass logic, calorie scaler, DB insert loop) is preserved VERBATIM from the original route.

**Part B: Replace old route.ts with deprecation stub**

Replace `apps/trainer-web/src/app/api/nutrition/plans/[planId]/generate/route.ts` content with:

```typescript
import { NextResponse } from "next/server";

// This endpoint has been split into three sub-routes:
//   POST .../generate/start  — sets status='generating', returns immediately
//   POST .../generate/run    — runs AI generation (fire-and-forget from client)
//   GET  .../generate/status — polling endpoint
// This file is kept as a stub to prevent 404 on any stale client calls.
export async function POST() {
  return NextResponse.json(
    { error: "This endpoint has been replaced. Use /generate/start, /generate/run, and /generate/status." },
    { status: 410 }
  );
}
```
  </action>
  <verify>
    <automated>cd "C:/Users/Troy Morgan/OneDrive/coach-os/apps/trainer-web" && npx tsc --noEmit --project tsconfig.json 2>&1 | head -30</automated>
  </verify>
  <done>
    - `/generate/run/route.ts` exists with `export const maxDuration = 60`
    - Idempotency guard at top of POST handler checks generation_status before AI work
    - On completion: `generation_status` updated to 'complete'
    - On error: `generation_status` updated to 'error' + `generation_error` set
    - All AI logic (buildRichPrompt, buildSimplePrompt, extractRootJson, two-pass, calorie scaler, food dedup) preserved verbatim
    - `/generate/route.ts` replaced with 410 stub
    - `npx tsc --noEmit` passes with no new errors
  </done>
</task>

</tasks>

<verification>
- All three sub-route files exist: start/route.ts, run/route.ts, status/route.ts
- TypeScript compiles cleanly: `npx tsc --noEmit` in apps/trainer-web returns no errors
- run/route.ts contains `extractRootJson`, `buildRichPrompt`, `FIRST_PASS_MAX`, calorie scaler logic
- run/route.ts contains idempotency guard checking generation_status before AI work
- run/route.ts updates generation_status to 'complete' on success, 'error' on failure
- status/route.ts returns `{ generation_status, generation_error }`
- start/route.ts returns `{ status: 'generating' }` after UPDATE
</verification>

<success_criteria>
- `npx tsc --noEmit` exits 0
- Three sub-route files exist at correct paths
- Old route.ts is a 410 stub
- No AI logic was lost (grep for `extractRootJson` in run/route.ts returns a match)
</success_criteria>

<output>
After completion, create `.planning/phases/10-async-ai-generation/10-02-SUMMARY.md`
</output>
