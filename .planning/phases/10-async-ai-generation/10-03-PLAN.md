---
phase: 10-async-ai-generation
plan: 03
type: execute
wave: 3
depends_on:
  - 10-01
  - 10-02
files_modified:
  - apps/trainer-web/src/app/(app)/nutrition/[planId]/PlanBuilderClient.tsx
autonomous: false
requirements:
  - ASYNC-03
must_haves:
  truths:
    - "Clicking Generate fires POST /start immediately and returns to coach without a 26s hang"
    - "A spinner + 'Generating your plan...' message appears while polling"
    - "When generation_status='complete' the plan reloads automatically (days appear)"
    - "When generation_status='error' the coach sees the error message and a Retry button"
    - "Retry resets status by calling /start again then /run again"
  artifacts:
    - path: "apps/trainer-web/src/app/(app)/nutrition/[planId]/PlanBuilderClient.tsx"
      provides: "Updated GenerateModal with async start+run+poll flow"
      contains: "generate/start"
  key_links:
    - from: "GenerateModal (PlanBuilderClient.tsx)"
      to: "/api/nutrition/plans/[planId]/generate/start"
      via: "fetch POST on form submit"
      pattern: "generate/start"
    - from: "GenerateModal (PlanBuilderClient.tsx)"
      to: "/api/nutrition/plans/[planId]/generate/status"
      via: "setInterval polling every 3s"
      pattern: "generate/status"
---

<objective>
Update `GenerateModal` in `PlanBuilderClient.tsx` to use the new async three-endpoint pattern:
1. POST /start — fires immediately on form submit
2. POST /run — fire-and-forget (no await, no response handling)
3. GET /status — polled every 3 seconds until status is 'complete' or 'error'

Replace the old single-fetch blocking pattern with the new async flow. Add loading spinner state during polling, error display with Retry button, and auto-reload on completion.

Purpose: Eliminates the 26s Netlify timeout that blocks coaches generating multi-day plans.
Output: Working async generate flow verified in production.
</objective>

<execution_context>
@C:/Users/Troy Morgan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Troy Morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-async-ai-generation/10-CONTEXT.md
@.planning/phases/10-async-ai-generation/10-02-SUMMARY.md

<interfaces>
<!-- Current GenerateModal state — located in PlanBuilderClient.tsx starting at line ~1094 -->

Current state (synchronous, to be replaced):
```typescript
const [generating, setGenerating] = useState(false);
const [error, setError] = useState<string | null>(null);

async function handleGenerate(e: React.FormEvent) {
  e.preventDefault();
  setGenerating(true);
  const res = await fetch(`/api/nutrition/plans/${planId}/generate`, {
    method: "POST", headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ goal, calorie_target, macro_split, dietary_restrictions }),
  });
  if (res.ok) { onGenerated(); }
  else { setError(data.error ?? "Generation failed"); }
  setGenerating(false);
}
```

New endpoints available (from Plan 02):
- POST `/api/nutrition/plans/${planId}/generate/start`   → { status: 'generating' }
- POST `/api/nutrition/plans/${planId}/generate/run`     → fire-and-forget (no await needed)
- GET  `/api/nutrition/plans/${planId}/generate/status`  → { generation_status, generation_error }

GenerateModal receives:
```typescript
{ planId: string; onClose: () => void; onGenerated: () => void }
```

Note: GenerateModal also has an IntakeWizard path that sends intake_data. The same body shape
must be forwarded to /start (or stored in component state and sent to /run).
Actually, /start does NOT need the body — it just sets status='generating'. The body
(intake_data / goal / calorie_target etc.) must be sent to /run.
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite GenerateModal with async start+run+poll pattern</name>
  <files>apps/trainer-web/src/app/(app)/nutrition/[planId]/PlanBuilderClient.tsx</files>
  <action>
Locate the `GenerateModal` function in `PlanBuilderClient.tsx` (starts at line ~1094). Replace the `generating` state and `handleGenerate` function with the following async pattern. Keep all form fields, UI layout, and IntakeWizard integration unchanged.

**State changes:**

Replace:
```typescript
const [generating, setGenerating] = useState(false);
const [error, setError] = useState<string | null>(null);
```

With:
```typescript
const [genPhase, setGenPhase] = useState<"idle" | "starting" | "polling" | "complete" | "error">("idle");
const [genError, setGenError] = useState<string | null>(null);
const pollIntervalRef = useRef<ReturnType<typeof setInterval> | null>(null);
```

Add `useRef` to imports at the top of the file if not already present (check — it likely is since it's a large React component).

**handleGenerate replacement:**

Replace the entire `handleGenerate` async function with:

```typescript
async function handleGenerate(e: React.FormEvent) {
  e.preventDefault();
  if (macroSum !== 100) {
    setGenError(`Macros must sum to 100% (currently ${macroSum}%)`);
    return;
  }
  await startGeneration();
}

async function startGeneration() {
  setGenPhase("starting");
  setGenError(null);

  // Clear any existing poll
  if (pollIntervalRef.current) {
    clearInterval(pollIntervalRef.current);
    pollIntervalRef.current = null;
  }

  // Build request body (same shape as before — goes to /run, not /start)
  const runBody = showIntakeWizard && intakeData
    ? JSON.stringify({ intake_data: intakeData, plan_length_days: planLengthDays })
    : JSON.stringify({
        goal,
        calorie_target: calorieTarget,
        macro_split: { protein_pct: proteinPct, carb_pct: carbPct, fat_pct: fatPct },
        dietary_restrictions: restrictions || null,
      });

  // Step 1: POST /start (fast, sets status='generating')
  try {
    const startRes = await fetch(`/api/nutrition/plans/${planId}/generate/start`, {
      method: "POST",
    });
    if (!startRes.ok) {
      const d = await startRes.json().catch(() => ({}));
      setGenError(d.error ?? "Failed to start generation");
      setGenPhase("error");
      return;
    }
  } catch {
    setGenError("Failed to start generation");
    setGenPhase("error");
    return;
  }

  setGenPhase("polling");

  // Step 2: POST /run — fire and forget (do NOT await, Netlify runs it async)
  fetch(`/api/nutrition/plans/${planId}/generate/run`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: runBody,
  }).catch(() => {
    // Network error on /run is surfaced via /status polling — ignore here
  });

  // Step 3: Poll /status every 3s
  pollIntervalRef.current = setInterval(async () => {
    try {
      const statusRes = await fetch(`/api/nutrition/plans/${planId}/generate/status`);
      if (!statusRes.ok) return; // transient error — keep polling
      const statusData = await statusRes.json();
      const status: string = statusData.generation_status ?? "generating";

      if (status === "complete") {
        clearInterval(pollIntervalRef.current!);
        pollIntervalRef.current = null;
        setGenPhase("complete");
        onGenerated(); // triggers plan reload in parent
      } else if (status === "error") {
        clearInterval(pollIntervalRef.current!);
        pollIntervalRef.current = null;
        setGenError(statusData.generation_error ?? "Generation failed");
        setGenPhase("error");
      }
      // else still 'generating' — keep polling
    } catch {
      // transient fetch error — keep polling
    }
  }, 3000);
}
```

Note: The `showIntakeWizard`, `intakeData`, `planLengthDays` variables are part of the existing GenerateModal state from the IntakeWizard integration. If their exact names differ (check the file), use the actual variable names. The key point is: the body for /run must be built from the same form state as the old single POST.

**Cleanup on modal close:**

Find the `onClose` button click handler and add cleanup:
```typescript
onClick={() => {
  if (pollIntervalRef.current) {
    clearInterval(pollIntervalRef.current);
    pollIntervalRef.current = null;
  }
  onClose();
}}
```

Also add a `useEffect` cleanup for unmount:
```typescript
useEffect(() => {
  return () => {
    if (pollIntervalRef.current) clearInterval(pollIntervalRef.current);
  };
}, []);
```

**UI changes in the JSX return:**

Replace all `generating` state references with `genPhase` checks:

1. Submit button disabled state: change `disabled={generating}` to `disabled={genPhase === "starting" || genPhase === "polling"}`

2. The existing error display `{error && <p className="text-sm text-red-500">{error}</p>}` — replace with:
```tsx
{genError && (
  <div className="text-sm text-red-500 space-y-2">
    <p>{genError}</p>
    {genPhase === "error" && (
      <button
        type="button"
        onClick={startGeneration}
        className="text-sm underline text-brand-600 hover:text-brand-700"
      >
        Retry
      </button>
    )}
  </div>
)}
```

3. Replace the existing generating spinner/text with a polling-aware version. Find where `generating && <p>Generating...</p>` or similar appears (or the button text). Replace button text with:
```tsx
{genPhase === "starting" ? "Starting..." :
 genPhase === "polling" ? "Generating your plan..." :
 "Generate Plan"}
```

4. Add a spinner during polling (just above or below the submit button, inside the form):
```tsx
{(genPhase === "starting" || genPhase === "polling") && (
  <div className="flex items-center gap-2 text-sm text-gray-500 dark:text-gray-400">
    <svg className="animate-spin h-4 w-4 text-brand-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"/>
      <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"/>
    </svg>
    <span>{genPhase === "polling" ? "Generating your plan — this takes 30–60 seconds..." : "Starting..."}</span>
  </div>
)}
```

Keep all other JSX in GenerateModal unchanged (form fields, macro balance indicator, IntakeWizard toggle).
  </action>
  <verify>
    <automated>cd "C:/Users/Troy Morgan/OneDrive/coach-os/apps/trainer-web" && npx tsc --noEmit --project tsconfig.json 2>&1 | head -30</automated>
  </verify>
  <done>
    - `npx tsc --noEmit` exits 0 with no new errors
    - GenerateModal no longer has `const [generating` — replaced by `genPhase`
    - File contains `generate/start`, `generate/run`, `generate/status` fetch calls
    - File contains `setInterval` and `clearInterval` for polling
    - Retry button present when genPhase === 'error'
    - Spinner present during starting/polling phases
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Full async generation flow:
    - POST /start sets status='generating' and returns fast
    - POST /run executes AI work in background
    - GET /status polled every 3s until complete/error
    - GenerateModal shows spinner + "Generating your plan..." during polling
    - On complete: plan reloads with generated days
    - On error: error message + Retry button shown
  </what-built>
  <how-to-verify>
    1. Deploy: `cd apps/trainer-web && netlify deploy --prod --trigger` (commit + push first)
    2. Open a meal plan in the coach UI at /nutrition/[planId]
    3. Click "Generate with AI" — fill in any goal + calorie target
    4. Click Generate: confirm the modal shows spinner immediately (no 26s hang)
    5. Wait 30-60s: plan should reload with generated days appearing in the builder
    6. Check Netlify function logs — /start and /run should both appear as separate invocations
    7. Optional error test: temporarily set an invalid ANTHROPIC_API_KEY in Netlify, generate, confirm error message + Retry button appear

    Expected: Generate button triggers fast response, spinner shows, days populate after 30-60s without any timeout error.
  </how-to-verify>
  <resume-signal>Type "approved" if generation works end-to-end, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
- TypeScript compiles cleanly
- GenerateModal uses genPhase state (not generating boolean)
- Three endpoint calls present in component: generate/start, generate/run, generate/status
- Polling setInterval with 3000ms interval
- clearInterval on completion, error, and unmount
- Retry button triggers startGeneration() directly
- Human checkpoint approved: coach can generate a plan without hitting 26s timeout
</verification>

<success_criteria>
Coach clicks Generate → spinner appears within 200ms → plan populates within 60s → no Netlify timeout error in function logs.
</success_criteria>

<output>
After completion, create `.planning/phases/10-async-ai-generation/10-03-SUMMARY.md`
</output>
