---
phase: 09-ai-feedback-loop-versioning
plan: "02"
type: execute
wave: 2
depends_on:
  - "09-01"
files_modified:
  - apps/trainer-web/src/app/api/nutrition/feedback/[id]/draft/route.ts
  - apps/trainer-web/src/app/api/nutrition/feedback/[id]/route.ts
  - apps/trainer-web/src/app/api/nutrition/plans/[planId]/version/route.ts
autonomous: true
requirements:
  - FEEDBACK-VERSIONING-02
  - FEEDBACK-VERSIONING-03
must_haves:
  truths:
    - "POST /api/nutrition/feedback/[id]/draft reads the feedback row + its meal's component, calls Claude, writes ai_draft_* columns back to the feedback row"
    - "GET /api/nutrition/feedback/[id] returns the feedback row with ai_draft columns and joined meal/component/food_item data for the review UI"
    - "POST /api/nutrition/plans/[planId]/version deep-copies the entire plan (days/meals/components), increments version, applies the component swap, marks new plan as published"
    - "Version endpoint links the new plan via parent_plan_id = planId"
  artifacts:
    - path: "apps/trainer-web/src/app/api/nutrition/feedback/[id]/draft/route.ts"
      provides: "POST handler: reads feedback, fetches original component + food_item, calls Claude, stores ai_draft columns"
      exports: ["POST"]
    - path: "apps/trainer-web/src/app/api/nutrition/feedback/[id]/route.ts"
      provides: "GET handler: returns feedback row with ai_draft columns + meal/component/food_item join"
      exports: ["GET", "PATCH"]
    - path: "apps/trainer-web/src/app/api/nutrition/plans/[planId]/version/route.ts"
      provides: "POST handler: deep-copy plan, increment version, apply swap, publish"
      exports: ["POST"]
  key_links:
    - from: "POST /api/nutrition/feedback/[id]/draft"
      to: "meal_plan_feedback.ai_draft_food_item_id + ai_draft_qty_g + ai_draft_reasoning"
      via: "Supabase UPDATE after Claude response"
      pattern: "supabase.from\\(\"meal_plan_feedback\"\\).update"
    - from: "POST /api/nutrition/plans/[planId]/version"
      to: "meal_plans (new row with parent_plan_id)"
      via: "deep copy: insert plan → copy days → copy meals → copy components with optional swap"
      pattern: "parent_plan_id.*planId"
---

<objective>
Create three API routes: the AI draft endpoint that calls Claude to suggest a food swap, the feedback detail endpoint for the review UI, and the version creation endpoint that deep-copies a plan.

Purpose: These are the core business logic endpoints the coach review UI (Plan 03) depends on.

Output: Three new route files in the `api/nutrition/` tree.
</objective>

<execution_context>
@C:/Users/Troy Morgan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Troy Morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-ai-feedback-loop-versioning/09-01-SUMMARY.md

<interfaces>
<!-- Auth pattern (from plans/[planId]/route.ts): -->
```typescript
import { createClient } from "@/lib/supabase/server";

async function getOrgAndUser(supabase: Awaited<ReturnType<typeof createClient>>) {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return { orgId: null, userId: null };
  const { data: membership } = await supabase
    .from("org_members").select("org_id").eq("user_id", user.id).single();
  return { orgId: membership?.org_id ?? null, userId: user.id };
}
// Next.js 15 async params:
export async function POST(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) { const { id } = await params; ... }
```

<!-- meal_plan_feedback schema (after 0042 + 0043): -->
```typescript
// meal_plan_feedback columns:
// id, plan_id, meal_id (nullable), client_id, type, scope, comment, forward, status,
// ai_draft_food_item_id (nullable uuid FK food_items), ai_draft_qty_g (nullable numeric),
// ai_draft_reasoning (nullable text), created_at
```

<!-- meal_plans deep-copy logic: -->
// Source plan: id, org_id, client_id, name, start_date, end_date (copy these fields)
// New plan: version = source.version + 1, parent_plan_id = source.id, status = 'published', published_at = now()
// Copy chain: days (plan_id → new plan id) → meals (day_id → new day id) → components (meal_id → new meal id)
// The swap: if component.id === body.component_id, replace food_item_id + qty_g with draft values

<!-- AI generation pattern (from generate/route.ts): -->
```typescript
// Call Claude via REST (not SDK — matches existing pattern):
const aiResponse = await fetch("https://api.anthropic.com/v1/messages", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
    "x-api-key": process.env.ANTHROPIC_API_KEY!,
    "anthropic-version": "2023-06-01",
  },
  body: JSON.stringify({
    model: "claude-sonnet-4-6",
    max_tokens: 1024,
    messages: [{ role: "user", content: prompt }],
  }),
});
const aiData = await aiResponse.json();
const text: string = aiData.content?.[0]?.text ?? "";
```

<!-- food_items schema (relevant subset): -->
```typescript
interface FoodItem {
  id: string;
  food_name: string;
  food_group: string | null;
  energy_kcal: number | null;
  protein_g: number | null;
  fat_g: number | null;
  carb_g: number | null;
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: AI draft endpoint — POST /api/nutrition/feedback/[id]/draft</name>
  <files>
    apps/trainer-web/src/app/api/nutrition/feedback/[id]/draft/route.ts
    apps/trainer-web/src/app/api/nutrition/feedback/[id]/route.ts
  </files>
  <action>
Create directory structure: `src/app/api/nutrition/feedback/[id]/draft/route.ts`

**`route.ts` at `feedback/[id]/route.ts` — GET + PATCH:**

```typescript
// GET: return feedback row with joined data needed for review UI
// - Select: feedback.*, meal:meal_plan_meals(id, meal_type, title),
//   original_component:meal_plan_components(id, qty_g, custom_name, food_item:food_items(*)),
//   draft_food:food_items(id, food_name, food_group, energy_kcal, protein_g, fat_g, carb_g)
//   joined to ai_draft_food_item_id
// - Auth: verify feedback.plan_id belongs to org (JOIN meal_plans + org_members)
// - Note: Supabase can't join ai_draft_food_item_id as a named relation without a named FK;
//   instead fetch feedback row first, then fetch food_items by ai_draft_food_item_id separately
//   (two queries, simpler than fighting Supabase join naming for non-standard FK field)

// PATCH: update status only (mark as reviewed)
// - Accept body: { status: 'reviewed' }
// - Auth: same org check
```

**`draft/route.ts` — POST only:**

Logic:
1. Load the feedback row (id, plan_id, meal_id, type, comment, scope). Verify it belongs to coach's org via meal_plans.org_id → org_members check.
2. If `meal_id` is null, return 400 — can only draft a swap for meal-level feedback.
3. Load the meal's components with food_item join: `meal_plan_components where meal_id = feedback.meal_id, food_item:food_items(*)`.
4. If the feedback type is `substitution` or `dislike` or `allergy`, the component to swap is the first component in the meal (sort_order 0) — or if only one component exists, use that one. Store `component_id` for return value.
5. Build a Claude prompt:
   ```
   You are a sports dietitian. A personal training client left this feedback on their meal plan:
   Feedback type: {type}
   Comment: "{comment}"
   Scope: {scope}

   Current meal: {meal_type} — {title if present}
   Component to substitute: {food_name}, {qty_g}g (provides per serving: {kcal}kcal, {protein_g}g protein, {fat_g}g fat, {carb_g}g carbs)

   Suggest ONE replacement food from Australian foods that:
   - Addresses the client feedback
   - Provides similar macros (within 15% of protein, fat, carbs per adjusted qty)
   - Is a realistic, commonly available food
   - Adjust the qty_g so the macros closely match the original

   Respond with ONLY valid JSON, no commentary:
   {
     "food_name": "...",
     "qty_g": 120,
     "reasoning": "one sentence explanation"
   }
   ```
6. Call Claude (`claude-sonnet-4-6`, max_tokens 512) using the existing fetch pattern from generate/route.ts.
7. Parse the JSON response. Extract `food_name`, `qty_g`, `reasoning`.
8. Search `food_items` for the suggested food: `SELECT id, food_name FROM food_items WHERE food_name ILIKE '%{food_name}%' LIMIT 1`. If no match found, try a broader trigram search using `food_name ILIKE '%{first_word}%'`.
9. UPDATE `meal_plan_feedback` SET `ai_draft_food_item_id = food_item.id, ai_draft_qty_g = qty_g, ai_draft_reasoning = reasoning` WHERE id = feedbackId.
10. Return `{ draft: { food_item_id, food_item_name, qty_g, reasoning, component_id } }` (201).
11. If Claude fails or JSON parse fails, return 500 with error message (do NOT partially update).
12. Use `max_tokens: 512` not 8192 — this is a focused single-food suggestion.

**TypeScript compile requirement:** Both files must produce zero tsc errors. Use `as any` for Supabase deep join types where needed (established pattern from Phase 8).
  </action>
  <verify>
    <automated>cd "C:/Users/Troy Morgan/OneDrive/coach-os/apps/trainer-web" && npx tsc --noEmit 2>&1 | tail -5</automated>
  </verify>
  <done>Files exist at correct paths. TypeScript compiles with zero errors. POST /api/nutrition/feedback/[id]/draft returns 401 without auth (correct gate). GET /api/nutrition/feedback/[id] returns 401 without auth.</done>
</task>

<task type="auto">
  <name>Task 2: Version creation endpoint — POST /api/nutrition/plans/[planId]/version</name>
  <files>apps/trainer-web/src/app/api/nutrition/plans/[planId]/version/route.ts</files>
  <action>
Create `src/app/api/nutrition/plans/[planId]/version/route.ts`.

**POST handler logic:**

Body accepts: `{ component_id: string, new_food_item_id: string, new_qty_g: number, feedback_id?: string }`

Steps:
1. Auth: get org + user, verify plan belongs to org.
2. Validate inputs: `component_id`, `new_food_item_id`, `new_qty_g` all required. Validate `new_food_item_id` exists in `food_items` table.
3. Load the source plan's flat metadata: `id, org_id, client_id, name, start_date, end_date, version`.
4. Create the new `meal_plans` row:
   ```typescript
   const { data: newPlan } = await supabase.from("meal_plans").insert({
     org_id: orgId,
     client_id: sourcePlan.client_id,
     created_by: userId,
     name: sourcePlan.name,
     start_date: sourcePlan.start_date,
     end_date: sourcePlan.end_date,
     status: "published",
     version: sourcePlan.version + 1,
     parent_plan_id: planId,
     published_at: new Date().toISOString(),
   }).select().single();
   ```
5. Load all days for the source plan: `SELECT * FROM meal_plan_days WHERE plan_id = planId ORDER BY day_number`.
6. For each source day: INSERT new day (plan_id = newPlan.id, day_number, date). Then load meals for that day. For each meal: INSERT new meal (day_id = newDay.id, meal_type, title, note, sort_order). Then load components for that meal. For each component:
   - If `component.id === component_id` (the swapped one): INSERT with `food_item_id = new_food_item_id, qty_g = new_qty_g`
   - Otherwise: INSERT with original `food_item_id, qty_g, custom_name, sort_order`
7. If `feedback_id` provided: UPDATE `meal_plan_feedback SET status = 'reviewed'` WHERE id = feedback_id (marks the feedback as actioned).
8. Return `{ plan: { id: newPlan.id, version: newPlan.version } }` (201).

**Error handling:** If any step fails, do NOT attempt rollback (Supabase doesn't support transactions via JS client easily — partial plans are acceptable; coach can delete and retry). Return 500 with descriptive error.

**Performance note:** This iterates days×meals×components in sequence. For a 7-day plan with ~4 meals/day and ~3 components/meal that's ~84 INSERT calls. Acceptable for a coach-triggered action (not a hot path). Do NOT attempt bulk inserts — sequential is simpler and less error-prone.
  </action>
  <verify>
    <automated>cd "C:/Users/Troy Morgan/OneDrive/coach-os/apps/trainer-web" && npx tsc --noEmit 2>&1 | tail -5</automated>
  </verify>
  <done>File exists. TypeScript compiles with zero errors. POST /api/nutrition/plans/[planId]/version returns 401 without auth.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- Three files exist at correct paths
- All return 401 for unauthenticated requests (verified via curl or browser)
</verification>

<success_criteria>
Coach feedback item can be processed end-to-end via API: draft → review → version publish. Plan 03 (coach UI) can call these endpoints directly.
</success_criteria>

<output>
After completion, create `.planning/phases/09-ai-feedback-loop-versioning/09-02-SUMMARY.md`
</output>
