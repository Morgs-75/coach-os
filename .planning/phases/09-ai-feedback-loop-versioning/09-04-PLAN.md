---
phase: 09-ai-feedback-loop-versioning
plan: "04"
type: execute
wave: 4
depends_on:
  - "09-03"
files_modified:
  - apps/trainer-web/src/app/api/nutrition/plans/[planId]/versions/route.ts
  - apps/trainer-web/src/app/(app)/nutrition/[planId]/PlanBuilderClient.tsx
  - apps/trainer-web/src/app/(portal)/portal/[token]/NutritionView.tsx
autonomous: false
requirements:
  - FEEDBACK-VERSIONING-06
  - FEEDBACK-VERSIONING-07
must_haves:
  truths:
    - "Coach plan builder shows a version selector dropdown when parent_plan_id or child versions exist"
    - "Version selector shows v1, v2 etc. formatted labels and navigates to the selected plan's /nutrition/[planId] page"
    - "Version history is complete regardless of depth — all versions in the chain appear in the selector"
    - "Client portal NutritionView shows a version badge on the plan header (e.g. 'v2')"
    - "Client portal shows only the latest published version by default (existing behavior unchanged)"
    - "Human verifies: approve a feedback draft → new version appears in version selector → portal shows updated version badge"
  artifacts:
    - path: "apps/trainer-web/src/app/api/nutrition/plans/[planId]/versions/route.ts"
      provides: "GET handler returning all plans in the version chain via iterative root-finding"
      exports: ["GET"]
    - path: "apps/trainer-web/src/app/(app)/nutrition/[planId]/PlanBuilderClient.tsx"
      provides: "Version selector UI above plan header"
      contains: "version selector"
    - path: "apps/trainer-web/src/app/(portal)/portal/[token]/NutritionView.tsx"
      provides: "Version badge on plan name header"
      contains: "version"
  key_links:
    - from: "PlanBuilderClient.tsx version selector"
      to: "GET /api/nutrition/plans/[planId]/versions"
      via: "fetch on mount to load sibling versions"
      pattern: "fetch.*versions"
    - from: "NutritionView.tsx version badge"
      to: "plan.version prop"
      via: "inline badge render"
      pattern: "v\\{.*version\\}"
---

<objective>
Add version selectors to the coach plan builder and a version badge to the client portal nutrition view. Finish with a human verification checkpoint.

Purpose: Coaches and clients need visibility into version history — the version chain built by Plans 01-03 becomes navigable here.

Output: Version selector in PlanBuilderClient, version badge in NutritionView, human checkpoint approval.
</objective>

<execution_context>
@C:/Users/Troy Morgan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Troy Morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-ai-feedback-loop-versioning/09-03-SUMMARY.md

<interfaces>
<!-- PlanBuilderClient.tsx current Plan interface (Phase 7): -->
```typescript
interface Plan {
  id: string;
  name: string;
  status: "draft" | "published";
  version: number;           // already exists
  start_date: string | null;
  end_date: string | null;
  published_at: string | null;
  client: PlanClient | null;
  days: Day[];
  // parent_plan_id will be available after 0043 migration
}
```

<!-- Version selector needs a new API endpoint: -->
// GET /api/nutrition/plans/[planId]/versions
// Returns all plans in the same version chain — uses iterative root-finding (see Task 1 action).

<!-- NutritionView.tsx current props (Phase 8): -->
```typescript
// Props received: plan: NutritionPlan | null, token: string
// NutritionPlan has: id, name, start_date, end_date, version (number), status, days[]
// The 'version' field is already in meal_plans — just needs to be surfaced in the portal page.tsx fetch
```

<!-- portal page.tsx meal plan fetch (Phase 8 pattern): -->
// page.tsx fetches meal plan via Supabase:
//   .from("meal_plans").select("*, days:meal_plan_days(...)").eq("client_id", client.id)
//     .eq("status", "published").order("published_at", { ascending: false }).limit(1).maybeSingle()
// The 'version' column is in meal_plans so it's already included in the * select
// NutritionView just needs to render it

<!-- Version badge design: -->
// Inline badge next to plan name in NutritionView header:
//   <span className="ml-2 text-xs font-medium px-2 py-0.5 rounded-full bg-blue-100 text-blue-700">
//     v{plan.version}
//   </span>
// This is minimal — just shows the version number. No version selector in portal (clients see current).
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Version selector in coach plan builder</name>
  <files>
    apps/trainer-web/src/app/api/nutrition/plans/[planId]/versions/route.ts
    apps/trainer-web/src/app/(app)/nutrition/[planId]/PlanBuilderClient.tsx
  </files>
  <action>
**1. Create `src/app/api/nutrition/plans/[planId]/versions/route.ts` — GET handler:**

Logic:
1. Auth: get org, verify plan belongs to org.
2. Load the current plan: `{ id, version, parent_plan_id }`.
3. Find the root plan ID using an **iterative walk** — NOT a fixed 2-level lookup:

```typescript
// Iterative root-finding: walk parent_plan_id chain until we reach a plan with parent_plan_id = null
let rootId = planId;
let currentId = planId;
const MAX_DEPTH = 50; // safety cap to prevent infinite loops from corrupt data
let depth = 0;

while (depth < MAX_DEPTH) {
  const { data: current } = await supabase
    .from("meal_plans")
    .select("id, parent_plan_id")
    .eq("id", currentId)
    .eq("org_id", orgId)
    .single();

  if (!current) break; // plan not found or not in org

  if (!current.parent_plan_id) {
    rootId = current.id; // this IS the root
    break;
  }

  // Walk up
  currentId = current.parent_plan_id;
  depth++;
}
```

This handles any depth of version chain (v1 → v2 → v3 → v4 → ...), not just 3 versions. The `MAX_DEPTH` of 50 is a safety cap only — in practice plans will be v1-v5 at most.

4. Load all versions: `SELECT id, version, status, published_at FROM meal_plans WHERE (id = rootId OR parent_plan_id = rootId) AND org_id = orgId ORDER BY version ASC`.

**Note:** This query only returns direct children of rootId (depth=1 children), not grandchildren (depth=2+). This is intentional for Phase 9: the version creation endpoint always sets `parent_plan_id = original planId` passed to it (Plan 02 action). Meaning v3's parent is v2, not v1. So this query would miss v3 if root is v1.

To handle arbitrary depth correctly, use a recursive approach:

```typescript
// Load ALL plans in the version chain using the root walk result + a recursive query:
// Option A — client-side BFS (simple, performant for <50 versions):
const allVersions: VersionSummary[] = [];
const queue = [rootId];
const seen = new Set<string>();

while (queue.length > 0) {
  const currentBatch = queue.splice(0, queue.length); // drain queue
  for (const id of currentBatch) {
    if (seen.has(id)) continue;
    seen.add(id);
  }

  // Fetch: root + all plans whose parent is any id in currentBatch
  const { data: batch } = await supabase
    .from("meal_plans")
    .select("id, version, status, published_at, parent_plan_id")
    .or(`id.in.(${[...seen].join(",")}),parent_plan_id.in.(${currentBatch.join(",")})`)
    .eq("org_id", orgId)
    .order("version", { ascending: true });

  for (const row of batch ?? []) {
    if (!seen.has(row.id)) {
      allVersions.push(row);
      queue.push(row.id); // follow children
      seen.add(row.id);
    } else if (!allVersions.find(v => v.id === row.id)) {
      allVersions.push(row);
    }
  }
  if (queue.length === 0) break;
}
```

This BFS correctly retrieves all versions in the chain regardless of depth. If this feels complex, use the simpler PostgreSQL recursive CTE approach:

```sql
-- Execute via supabase.rpc or raw query if available, otherwise use the BFS above
WITH RECURSIVE chain AS (
  SELECT id, version, status, published_at, parent_plan_id
  FROM meal_plans WHERE id = $rootId AND org_id = $orgId
  UNION ALL
  SELECT m.id, m.version, m.status, m.published_at, m.parent_plan_id
  FROM meal_plans m JOIN chain c ON m.parent_plan_id = c.id
)
SELECT id, version, status, published_at FROM chain ORDER BY version ASC
```

**Recommendation:** Use the BFS approach (no raw SQL needed). For Phase 9 with typical depth of 2-5, this fires at most 2-3 Supabase queries.

5. Return `{ versions: allVersions.sort((a, b) => a.version - b.version) }`.

**2. Modify `PlanBuilderClient.tsx` — add version selector:**

Add state: `const [versions, setVersions] = useState<VersionSummary[]>([])`.

```typescript
interface VersionSummary {
  id: string;
  version: number;
  status: "draft" | "published";
  published_at: string | null;
}
```

Load versions on mount alongside loadPlan (fire concurrently with loadPlan in the useEffect):
```typescript
const loadVersions = useCallback(async () => {
  const res = await fetch(`/api/nutrition/plans/${planId}/versions`);
  if (res.ok) {
    const data = await res.json();
    setVersions(data.versions ?? []);
  }
}, [planId]);

useEffect(() => {
  loadPlan();
  loadVersions();
}, [planId]);
```

Render version selector ONLY when `versions.length > 1` (no selector for single-version plans).
Position: above the plan header (before the plan name h1), right-aligned.

```tsx
{versions.length > 1 && (
  <div className="flex justify-end mb-3">
    <select
      value={planId}
      onChange={(e) => { window.location.href = `/nutrition/${e.target.value}`; }}
      className="text-sm border border-gray-300 dark:border-gray-600 rounded-lg px-3 py-1.5
                 focus:outline-none focus:ring-2 focus:ring-brand-500 dark:bg-gray-800 dark:text-gray-100"
    >
      {versions.map((v) => (
        <option key={v.id} value={v.id}>
          v{v.version} — {v.status === "published" ? "Published" : "Draft"}
          {v.id === planId ? " (current)" : ""}
        </option>
      ))}
    </select>
  </div>
)}
```

Using `window.location.href` for navigation (not Next.js router) to force a full page reload — ensures loadPlan fires fresh for the new planId. This is a simple and reliable pattern for this low-frequency navigation.
  </action>
  <verify>
    <automated>cd "C:/Users/Troy Morgan/OneDrive/coach-os/apps/trainer-web" && npx tsc --noEmit 2>&1 | tail -10</automated>
  </verify>
  <done>versions route exists. PlanBuilderClient.tsx loads versions on mount. TypeScript compiles clean. Version selector renders when versions.length > 1 (will be testable after approving a draft in the checkpoint).</done>
</task>

<task type="auto">
  <name>Task 2: Version badge in client portal NutritionView</name>
  <files>
    apps/trainer-web/src/app/(portal)/portal/[token]/NutritionView.tsx
  </files>
  <action>
Modify `NutritionView.tsx` — add version badge to the plan header.

Current plan header renders the plan name. The `NutritionPlan` type already includes `version: number` (it comes from `meal_plans.*` in the portal page.tsx fetch which includes all columns including version).

If `NutritionPlan` type in NutritionView.tsx does NOT already have `version`:
- Add `version: number` to the `NutritionPlan` interface

Find the plan name heading (renders `{plan.name}`) and add the version badge inline:

```tsx
<div className="flex items-center gap-2 flex-wrap">
  <h2 className="text-lg font-semibold text-gray-900 dark:text-gray-100">
    {plan.name}
  </h2>
  <span className="text-xs font-medium px-2 py-0.5 rounded-full bg-blue-100 text-blue-700">
    v{plan.version}
  </span>
</div>
```

Also check: the portal `page.tsx` fetches `meal_plans` with `*` which includes `version`. If the NutritionPlan type passed to NutritionView does NOT include version (check the existing type definition), add it to the type and pass it through. No other changes to page.tsx are required — `*` already pulls version from the DB.

No other changes to NutritionView — portal clients see only the current (latest published) version. The version badge is purely informational.
  </action>
  <verify>
    <automated>cd "C:/Users/Troy Morgan/OneDrive/coach-os/apps/trainer-web" && npx tsc --noEmit 2>&1 | tail -10</automated>
  </verify>
  <done>NutritionView.tsx has version badge. TypeScript compiles clean. Portal nutrition tab shows "v1" or "v2" badge next to plan name.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Full Phase 9 AI feedback loop and versioning:
    - DB: parent_plan_id + ai_draft columns (Plan 01)
    - API: AI draft endpoint, version creation endpoint, feedback list API (Plan 02)
    - Coach UI: Feedback tab in /nutrition with FeedbackInbox + DraftReviewModal with edit overrides (Plan 03)
    - Version selector in coach plan builder, version badge in client portal (Plan 04)
  </what-built>
  <how-to-verify>
    1. Deploy: commit + push to GitHub, then run `cd apps/trainer-web && netlify deploy --prod --trigger` from the project root.
    2. In the client portal (portal/[token]) → Nutrition tab: confirm a version badge (e.g. "v1") appears next to the plan name.
    3. Submit feedback from portal: open a meal → "Leave feedback" → select type "Substitution" → write a comment → Submit.
    4. In coach app (/nutrition): click the "Feedback" tab. Confirm the new feedback row appears with the correct client name, meal, and comment.
    5. Click "Get AI Draft" on the feedback row. Wait for Claude to respond (~5-10 seconds). Confirm the DraftReviewModal opens showing:
       - "Original" column with food name + qty
       - "AI Suggestion" column with different food name + qty
       - Claude's reasoning text
       - "Edit AI suggestion" expandable section with a qty override input and food search input
    6. Test the edit override: expand "Edit AI suggestion", change the qty value. Confirm the "AI Suggestion" qty in the comparison table updates in real-time.
    7. Click "Approve & Publish New Version". Confirm the modal transitions to "New version published! v2 is now live."
    8. Navigate to /nutrition/[planId] for the client's plan. Confirm the version selector shows "v1" and "v2". Switch to v2 — confirm it loads.
    9. Back in the client portal, refresh the Nutrition tab. Confirm the plan now shows "v2" badge.
    10. The old v1 is still accessible via the coach version selector (navigate to v1, confirm it loads).
  </how-to-verify>
  <resume-signal>Type "approved" if all 10 steps pass, or describe any issues found.</resume-signal>
</task>

</tasks>

<verification>
- TypeScript compiles with zero errors after both code tasks
- Version selector renders in coach plan builder for versioned plans
- Version badge renders in client portal NutritionView
- Human checkpoint approved: full feedback → draft → edit override → approve → new version flow confirmed
</verification>

<success_criteria>
Phase 9 complete: coach sees feedback, AI drafts a swap, coach optionally edits qty/food before approving, new plan version published and visible to client. Version history navigable by coach for any chain depth. Client portal shows current version badge.
</success_criteria>

<output>
After completion, create `.planning/phases/09-ai-feedback-loop-versioning/09-04-SUMMARY.md`
</output>
