---
phase: 09-ai-feedback-loop-versioning
plan: "04"
type: execute
wave: 4
depends_on:
  - "09-03"
files_modified:
  - apps/trainer-web/src/app/(app)/nutrition/[planId]/PlanBuilderClient.tsx
  - apps/trainer-web/src/app/(portal)/portal/[token]/NutritionView.tsx
  - apps/trainer-web/src/app/(portal)/portal/[token]/page.tsx
autonomous: false
requirements:
  - FEEDBACK-VERSIONING-06
  - FEEDBACK-VERSIONING-07
must_haves:
  truths:
    - "Coach plan builder shows a version selector dropdown when parent_plan_id or child versions exist"
    - "Version selector shows v1, v1.1, v2 etc. formatted labels and navigates to the selected plan's /nutrition/[planId] page"
    - "Client portal NutritionView shows a version badge on the plan header (e.g. 'v2')"
    - "Client portal shows only the latest published version by default (existing behavior unchanged)"
    - "Human verifies: approve a feedback draft → new version appears in version selector → portal shows updated version badge"
  artifacts:
    - path: "apps/trainer-web/src/app/(app)/nutrition/[planId]/PlanBuilderClient.tsx"
      provides: "Version selector UI above plan header"
      contains: "version selector"
    - path: "apps/trainer-web/src/app/(portal)/portal/[token]/NutritionView.tsx"
      provides: "Version badge on plan name header"
      contains: "version"
  key_links:
    - from: "PlanBuilderClient.tsx version selector"
      to: "GET /api/nutrition/plans/[planId]/versions (new endpoint)"
      via: "fetch on mount to load sibling versions"
      pattern: "fetch.*versions"
    - from: "NutritionView.tsx version badge"
      to: "plan.version prop"
      via: "inline badge render"
      pattern: "v\\{.*version\\}"
---

<objective>
Add version selectors to the coach plan builder and a version badge to the client portal nutrition view. Finish with a human verification checkpoint.

Purpose: Coaches and clients need visibility into version history — the version chain built by Plans 01-03 becomes navigable here.

Output: Version selector in PlanBuilderClient, version badge in NutritionView, human checkpoint approval.
</objective>

<execution_context>
@C:/Users/Troy Morgan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Troy Morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-ai-feedback-loop-versioning/09-03-SUMMARY.md

<interfaces>
<!-- PlanBuilderClient.tsx current Plan interface (Phase 7): -->
```typescript
interface Plan {
  id: string;
  name: string;
  status: "draft" | "published";
  version: number;           // already exists
  start_date: string | null;
  end_date: string | null;
  published_at: string | null;
  client: PlanClient | null;
  days: Day[];
  // parent_plan_id will be available after 0043 migration
}
```

<!-- Version selector needs a new API endpoint: -->
// GET /api/nutrition/plans/[planId]/versions
// Returns all plans in the same version chain as planId:
//   - Find root: if plan has parent_plan_id, follow up to root (or just query by parent chain)
//   - Simpler: query all plans WHERE (id = planId OR parent_plan_id = planId OR parent_plan_id IN
//     (SELECT id FROM meal_plans WHERE parent_plan_id = planId)) — this handles v1, v2, v3
//   - Even simpler for Phase 9 (max depth ~3): load plan, if it has parent_plan_id load parent,
//     then load all plans with parent_plan_id = root_id. Flatten and sort by version.
//   Returns: { versions: [{ id, version, status, published_at }] }

<!-- NutritionView.tsx current props (Phase 8): -->
```typescript
// Props received: plan: NutritionPlan | null, token: string
// NutritionPlan has: id, name, start_date, end_date, version (number), status, days[]
// The 'version' field is already in meal_plans — just needs to be surfaced in the portal page.tsx fetch
```

<!-- portal page.tsx meal plan fetch (Phase 8 pattern): -->
// page.tsx fetches meal plan via Supabase:
//   .from("meal_plans").select("*, days:meal_plan_days(...)").eq("client_id", client.id)
//     .eq("status", "published").order("published_at", { ascending: false }).limit(1).maybeSingle()
// The 'version' column is in meal_plans so it's already included in the * select
// NutritionView just needs to render it

<!-- Version badge design: -->
// Inline badge next to plan name in NutritionView header:
//   <span className="ml-2 text-xs font-medium px-2 py-0.5 rounded-full bg-blue-100 text-blue-700">
//     v{plan.version}
//   </span>
// This is minimal — just shows the version number. No version selector in portal (clients see current).
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Version selector in coach plan builder</name>
  <files>
    apps/trainer-web/src/app/api/nutrition/plans/[planId]/versions/route.ts
    apps/trainer-web/src/app/(app)/nutrition/[planId]/PlanBuilderClient.tsx
  </files>
  <action>
**1. Create `src/app/api/nutrition/plans/[planId]/versions/route.ts` — GET handler:**

Logic:
1. Auth: get org, verify plan belongs to org.
2. Load the current plan: `{ id, version, parent_plan_id }`.
3. Find the root plan ID:
   - If `plan.parent_plan_id` is null → current plan IS the root. `rootId = planId`
   - If `plan.parent_plan_id` is set → load parent to check if parent has a parent_plan_id. If parent.parent_plan_id is null → rootId = parent.id. (Only go 2 levels up — v3 plans link to v2 which links to v1 root).
   - This handles up to 3 versions (v1, v2, v3). For deeper chains (unlikely in practice), v1 is always the root (parent_plan_id = null).
4. Load all versions: `SELECT id, version, status, published_at FROM meal_plans WHERE (id = rootId OR parent_plan_id = rootId) AND org_id = orgId ORDER BY version ASC`.
5. Return `{ versions: data ?? [] }`.

**2. Modify `PlanBuilderClient.tsx` — add version selector:**

Add state: `const [versions, setVersions] = useState<VersionSummary[]>([])`.

```typescript
interface VersionSummary {
  id: string;
  version: number;
  status: "draft" | "published";
  published_at: string | null;
}
```

Load versions on mount alongside loadPlan (fire concurrently with loadPlan in the useEffect):
```typescript
const loadVersions = useCallback(async () => {
  const res = await fetch(`/api/nutrition/plans/${planId}/versions`);
  if (res.ok) {
    const data = await res.json();
    setVersions(data.versions ?? []);
  }
}, [planId]);

useEffect(() => {
  loadPlan();
  loadVersions();
}, [planId]);
```

Render version selector ONLY when `versions.length > 1` (no selector for single-version plans).
Position: above the plan header (before the plan name h1), right-aligned.

```tsx
{versions.length > 1 && (
  <div className="flex justify-end mb-3">
    <select
      value={planId}
      onChange={(e) => { window.location.href = `/nutrition/${e.target.value}`; }}
      className="text-sm border border-gray-300 dark:border-gray-600 rounded-lg px-3 py-1.5
                 focus:outline-none focus:ring-2 focus:ring-brand-500 dark:bg-gray-800 dark:text-gray-100"
    >
      {versions.map((v) => (
        <option key={v.id} value={v.id}>
          v{v.version} — {v.status === "published" ? "Published" : "Draft"}
          {v.id === planId ? " (current)" : ""}
        </option>
      ))}
    </select>
  </div>
)}
```

Using `window.location.href` for navigation (not Next.js router) to force a full page reload — ensures loadPlan fires fresh for the new planId. This is a simple and reliable pattern for this low-frequency navigation.
  </action>
  <verify>
    <automated>cd "C:/Users/Troy Morgan/OneDrive/coach-os/apps/trainer-web" && npx tsc --noEmit 2>&1 | tail -10</automated>
  </verify>
  <done>versions route exists. PlanBuilderClient.tsx loads versions on mount. TypeScript compiles clean. Version selector renders when versions.length > 1 (will be testable after approving a draft in the checkpoint).</done>
</task>

<task type="auto">
  <name>Task 2: Version badge in client portal NutritionView</name>
  <files>
    apps/trainer-web/src/app/(portal)/portal/[token]/NutritionView.tsx
  </files>
  <action>
Modify `NutritionView.tsx` — add version badge to the plan header.

Current plan header renders the plan name. The `NutritionPlan` type already includes `version: number` (it comes from `meal_plans.*` in the portal page.tsx fetch which includes all columns including version).

If `NutritionPlan` type in NutritionView.tsx does NOT already have `version`:
- Add `version: number` to the `NutritionPlan` interface

Find the plan name heading (renders `{plan.name}`) and add the version badge inline:

```tsx
<div className="flex items-center gap-2 flex-wrap">
  <h2 className="text-lg font-semibold text-gray-900 dark:text-gray-100">
    {plan.name}
  </h2>
  <span className="text-xs font-medium px-2 py-0.5 rounded-full bg-blue-100 text-blue-700">
    v{plan.version}
  </span>
</div>
```

Also check: the portal `page.tsx` fetches `meal_plans` with `*` which includes `version`. If the NutritionPlan type passed to NutritionView does NOT include version (check the existing type definition), add it to the type and pass it through.

No other changes to NutritionView — portal clients see only the current (latest published) version. The version badge is purely informational.
  </action>
  <verify>
    <automated>cd "C:/Users/Troy Morgan/OneDrive/coach-os/apps/trainer-web" && npx tsc --noEmit 2>&1 | tail -10</automated>
  </verify>
  <done>NutritionView.tsx has version badge. TypeScript compiles clean. Portal nutrition tab shows "v1" or "v2" badge next to plan name.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Full Phase 9 AI feedback loop and versioning:
    - DB: parent_plan_id + ai_draft columns (Plan 01)
    - API: AI draft endpoint, version creation endpoint, feedback list API (Plan 02)
    - Coach UI: Feedback tab in /nutrition with FeedbackInbox + DraftReviewModal (Plan 03)
    - Version selector in coach plan builder, version badge in client portal (Plan 04)
  </what-built>
  <how-to-verify>
    1. Deploy: commit + push to GitHub, then run `cd apps/trainer-web && netlify deploy --prod --trigger` from the project root.
    2. In the client portal (portal/[token]) → Nutrition tab: confirm a version badge (e.g. "v1") appears next to the plan name.
    3. Submit feedback from portal: open a meal → "Leave feedback" → select type "Substitution" → write a comment → Submit.
    4. In coach app (/nutrition): click the "Feedback" tab. Confirm the new feedback row appears with the correct client name, meal, and comment.
    5. Click "Get AI Draft" on the feedback row. Wait for Claude to respond (~5-10 seconds). Confirm the DraftReviewModal opens showing:
       - "Original" column with food name + qty
       - "AI Suggestion" column with different food name + qty
       - Claude's reasoning text
    6. Click "Approve & Publish New Version". Confirm the modal transitions to "New version published! v2 is now live."
    7. Navigate to /nutrition/[planId] for the client's plan. Confirm the version selector shows "v1" and "v2". Switch to v2 — confirm it loads.
    8. Back in the client portal, refresh the Nutrition tab. Confirm the plan now shows "v2" badge.
    9. The old v1 is still accessible via the coach version selector (navigate to v1, confirm it loads).
  </how-to-verify>
  <resume-signal>Type "approved" if all 9 steps pass, or describe any issues found.</resume-signal>
</task>

</tasks>

<verification>
- TypeScript compiles with zero errors after both code tasks
- Version selector renders in coach plan builder for versioned plans
- Version badge renders in client portal NutritionView
- Human checkpoint approved: full feedback → draft → approve → new version flow confirmed
</verification>

<success_criteria>
Phase 9 complete: coach sees feedback, AI drafts a swap, coach approves, new plan version published and visible to client. Version history navigable by coach. Client portal shows current version badge.
</success_criteria>

<output>
After completion, create `.planning/phases/09-ai-feedback-loop-versioning/09-04-SUMMARY.md`
</output>
