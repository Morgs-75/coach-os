---
phase: 09-ai-feedback-loop-versioning
plan: "03"
type: execute
wave: 3
depends_on:
  - "09-02"
files_modified:
  - apps/trainer-web/src/app/api/nutrition/feedback/route.ts
  - apps/trainer-web/src/app/(app)/nutrition/FeedbackInbox.tsx
  - apps/trainer-web/src/app/(app)/nutrition/DraftReviewModal.tsx
  - apps/trainer-web/src/app/(app)/nutrition/NutritionClient.tsx
autonomous: true
requirements:
  - FEEDBACK-VERSIONING-04
  - FEEDBACK-VERSIONING-05
must_haves:
  truths:
    - "Coach can see a list of pending feedback items in the /nutrition section with client name, meal, feedback type, and comment"
    - "Coach can click a feedback item and trigger AI draft — a loading state shows while Claude processes"
    - "Draft review modal shows: original food name + qty vs AI-suggested food name + qty + reasoning"
    - "Coach can accept the draft (creates new version) or reject it (marks reviewed without versioning)"
    - "After approve, a success state confirms new version published"
  artifacts:
    - path: "apps/trainer-web/src/app/api/nutrition/feedback/route.ts"
      provides: "GET handler returning pending feedback items with joined meal + client + plan data"
      exports: ["GET"]
    - path: "apps/trainer-web/src/app/(app)/nutrition/FeedbackInbox.tsx"
      provides: "Feedback list component showing pending items with Draft button"
      min_lines: 80
    - path: "apps/trainer-web/src/app/(app)/nutrition/DraftReviewModal.tsx"
      provides: "Modal: original vs AI swap comparison + accept/reject actions"
      min_lines: 100
  key_links:
    - from: "FeedbackInbox.tsx (Draft button)"
      to: "POST /api/nutrition/feedback/[id]/draft"
      via: "fetch call on button click"
      pattern: "fetch.*feedback.*draft"
    - from: "DraftReviewModal.tsx (Approve button)"
      to: "POST /api/nutrition/plans/[planId]/version"
      via: "fetch with component_id + new_food_item_id + new_qty_g"
      pattern: "fetch.*plans.*version"
---

<objective>
Build the coach feedback inbox and draft review modal in the `/nutrition` section. Coach can see pending feedback, trigger AI draft, review the swap, and approve to publish a new version.

Purpose: This is the coach-facing workflow that drives the feedback loop — the reason Phase 9 exists.

Output: `FeedbackInbox.tsx`, `DraftReviewModal.tsx`, GET feedback API, wired into `NutritionClient.tsx` as a new tab.
</objective>

<execution_context>
@C:/Users/Troy Morgan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Troy Morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-ai-feedback-loop-versioning/09-02-SUMMARY.md

<interfaces>
<!-- NutritionClient.tsx current structure (from Phase 6 — has tabs pattern we'll extend): -->
```typescript
// Current: single view showing meal plans list
// Phase 9: add "Feedback" tab alongside "Plans" tab
// Tab state pattern: const [activeTab, setActiveTab] = useState<"plans" | "feedback">("plans")
// NutritionClient already imports createClient and has org/user loading
// The feedback inbox component receives orgId as prop (NutritionClient resolves it)
```

<!-- GET /api/nutrition/feedback — new endpoint: -->
```typescript
// Query: meal_plan_feedback table
// Select: id, plan_id, meal_id, client_id, type, scope, comment, forward, status, created_at,
//         ai_draft_food_item_id, ai_draft_qty_g, ai_draft_reasoning
// Join: plan:meal_plans(id, name, version, client:clients(id, name, first_name, last_name)),
//       meal:meal_plan_meals(id, meal_type, title)
// Filter: feedback rows where plan.org_id = orgId (via EXISTS subquery)
// Default: status = 'pending' (query param ?status=all to include reviewed)
// Order: created_at DESC
// Returns: { feedback: FeedbackItem[] }
```

<!-- POST /api/nutrition/feedback/[id]/draft (from Plan 02): -->
```typescript
// Returns: { draft: { food_item_id, food_item_name, qty_g, reasoning, component_id } }
// Also updates meal_plan_feedback.ai_draft_* columns
```

<!-- GET /api/nutrition/feedback/[id] (from Plan 02): -->
```typescript
// Returns feedback row with original component + ai_draft food item details
// We need: original food name + qty, and ai_draft food item name + qty + reasoning
```

<!-- POST /api/nutrition/plans/[planId]/version (from Plan 02): -->
```typescript
// Body: { component_id: string, new_food_item_id: string, new_qty_g: number, feedback_id: string }
// Returns: { plan: { id: string, version: number } }
```

<!-- DraftReviewModal state machine: -->
// States: idle | drafting | draft_ready | approving | approved | rejected | error
// idle → drafting: coach clicks "Get AI Draft"
// drafting → draft_ready: Claude response received, draft stored in feedback row
// draft_ready → approving: coach clicks "Approve"
// approving → approved: version endpoint returns success
// draft_ready → rejected: coach clicks "Reject" (PATCH feedback status=reviewed)
// any → error: API call failed

<!-- Existing NutritionClient.tsx tab pattern (established in Phase 8 portal): -->
// Tab bar with brand-600 underline on active tab
// Tabs inside top div, content conditionally rendered below
// Pattern from PortalDashboard.tsx Phase 8 for reference
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Feedback list API + FeedbackInbox component</name>
  <files>
    apps/trainer-web/src/app/api/nutrition/feedback/route.ts
    apps/trainer-web/src/app/(app)/nutrition/FeedbackInbox.tsx
  </files>
  <action>
**1. Create `src/app/api/nutrition/feedback/route.ts` — GET handler:**

```typescript
import { NextResponse } from "next/server";
import { createClient } from "@/lib/supabase/server";

// getOrgAndUser helper (same pattern as other nutrition routes)

export async function GET(request: Request) {
  // Auth: get org
  // Parse ?status=all query param (default: only pending)
  // Query meal_plan_feedback with joins:
  //   SELECT feedback.*, plan:meal_plans!inner(id, name, version, client_id,
  //     client:clients(id, name, first_name, last_name)),
  //     meal:meal_plan_meals(id, meal_type, title)
  //   WHERE EXISTS (SELECT 1 FROM meal_plans mp JOIN org_members om ON om.org_id = mp.org_id
  //     WHERE mp.id = meal_plan_feedback.plan_id AND om.user_id = auth.uid())
  //
  // Implementation: use Supabase .from("meal_plan_feedback").select(`
  //   *, plan:meal_plans!inner(id, name, version, client:clients(id, name, first_name, last_name)),
  //   meal:meal_plan_meals(id, meal_type, title)
  // `)
  // .eq("plan.org_id", orgId)  ← this filters via the inner join
  // If status !== 'all': .eq("status", "pending")
  // .order("created_at", { ascending: false })
  //
  // Note: Supabase may not support .eq on a joined column directly.
  // Alternative safe query: load all feedback ids where plan.org_id = orgId via a subquery first:
  //   const { data: planIds } = await supabase.from("meal_plans").select("id").eq("org_id", orgId)
  //   then .in("plan_id", planIds.map(p => p.id))
  // Use this two-step approach (same pattern as Phase 8 portal two-step plan fetch)
  //
  // Return: { feedback: data ?? [] }
}
```

**2. Create `src/app/(app)/nutrition/FeedbackInbox.tsx` — client component:**

```typescript
"use client";
// Props: { orgId: string }
// State: items (FeedbackItem[]), loading, selectedItem (FeedbackItem | null), showDraftModal

interface FeedbackItem {
  id: string;
  plan_id: string;
  meal_id: string | null;
  client_id: string;
  type: string;
  scope: string;
  comment: string | null;
  status: "pending" | "reviewed";
  ai_draft_food_item_id: string | null;
  ai_draft_qty_g: number | null;
  ai_draft_reasoning: string | null;
  created_at: string;
  plan: { id: string; name: string; version: number; client: { id: string; name: string | null; first_name?: string | null; last_name?: string | null } | null };
  meal: { id: string; meal_type: string; title: string | null } | null;
}

// Load on mount via GET /api/nutrition/feedback
// Render: table with columns: Client | Plan | Meal | Type | Scope | Comment | Date | Action
// Each row shows:
//   - Client name (clientDisplayName helper)
//   - Plan name + version badge (e.g. "7-Day Plan v1")
//   - Meal type label (e.g. "Lunch") or "Plan-level" if meal_id is null
//   - Type badge (color-coded: substitution=blue, dislike=orange, allergy=red, other=gray)
//   - Scope (this_meal / going_forward / all_occurrences — formatted as readable label)
//   - Comment (truncated to 60 chars with title tooltip for full text)
//   - Date (formatted en-AU)
//   - "Get AI Draft" button (primary, disabled if meal_id is null — draft requires meal context)
//     OR if ai_draft_food_item_id already set: "Review Draft" button (secondary)
// Empty state: "No pending feedback" with gray border dashed card
// Pass selectedItem to <DraftReviewModal> and toggle modal open on button click
// On modal close / approved: reload the feedback list
```

FeedbackInbox should import DraftReviewModal and render it alongside the list (not inline).
  </action>
  <verify>
    <automated>cd "C:/Users/Troy Morgan/OneDrive/coach-os/apps/trainer-web" && npx tsc --noEmit 2>&1 | tail -5</automated>
  </verify>
  <done>Files exist. TypeScript compiles clean. GET /api/nutrition/feedback returns 401 without auth. FeedbackInbox renders with correct columns and "No pending feedback" empty state.</done>
</task>

<task type="auto">
  <name>Task 2: DraftReviewModal + wire NutritionClient tabs</name>
  <files>
    apps/trainer-web/src/app/(app)/nutrition/DraftReviewModal.tsx
    apps/trainer-web/src/app/(app)/nutrition/NutritionClient.tsx
  </files>
  <action>
**1. Create `DraftReviewModal.tsx`:**

```typescript
"use client";
// Props: { item: FeedbackItem | null, open: boolean, onClose: () => void, onApproved: () => void }
// Modal: fixed inset overlay (bg-black/50 z-50 flex items-center justify-center)
// Content card: max-w-lg, rounded-xl, bg-white dark:bg-gray-900, p-6

// State machine: idle | drafting | draft_ready | approving | approved | rejected | error
// Initial state: if item.ai_draft_food_item_id is already set → draft_ready; else → idle

// idle state:
//   "Get AI Draft" primary button → triggers POST /api/nutrition/feedback/[id]/draft
//   Shows item summary: feedback type, comment, meal name
//   Shows the component being considered: "Meal: {meal_type}" + "Comment: {comment}"

// drafting state:
//   Spinner + "Claude is generating a suggestion..."

// draft_ready state (after draft returned or item already has ai_draft):
//   Two-column comparison table:
//     | | Original | AI Suggestion |
//     | Food | {original component food name} | {ai_draft_food_item name} |
//     | Quantity | {original qty_g}g | {ai_draft_qty_g}g |
//   Reasoning box: gray bg, italic text, Claude's reasoning
//   TWO buttons:
//     - "Approve & Publish New Version" (green, primary) → triggers POST /api/nutrition/plans/[planId]/version
//     - "Reject" (outline gray) → PATCH /api/nutrition/feedback/[id] { status: "reviewed" }
//
//   For the original component: when entering draft_ready state after a fresh draft,
//   the draft endpoint returns { draft: { component_id, food_item_id, food_item_name, qty_g, reasoning } }
//   Store component_id + original food info in local state (originalComponent state).
//   For the original food name/qty: need to fetch GET /api/nutrition/feedback/[id] to get
//   the component's food_item join. Do this fetch in the same step as the draft call.
//   Alternatively: just show "Meal: {item.meal?.meal_type}" context and use feedback.comment
//   as context, since the exact "original component" is less critical to display
//   (coach already knows the plan). For simplicity: show original component data from the
//   draft response's component_id by fetching GET /api/nutrition/feedback/[id] after draft completes.
//   Use { draft_food_item_name, draft_qty_g, draft_reasoning, component_id, original_food_name, original_qty_g }
//   from the combined GET response.

// approving state: spinner + "Publishing new version..."

// approved state:
//   Green checkmark icon + "New version published!"
//   Info: "Version v{N+1} is now live in the client portal."
//   "Done" button → calls onApproved() + onClose()

// rejected state:
//   "Feedback marked as reviewed." + Close button

// error state:
//   Red banner with error message + "Try Again" button (resets to idle or draft_ready)

// Implementation note for original component data:
//   After POST /draft returns component_id, make a second call:
//   GET /api/nutrition/feedback/[id] which returns the feedback row with component join
//   (Task 1 of Plan 02 handles this). Store original_food_name, original_qty_g from that response.
```

**2. Modify `NutritionClient.tsx` — add Feedback tab:**

- Add `activeTab` state: `useState<"plans" | "feedback">("plans")`
- Add tab bar below the page title / above the toolbar:
  ```tsx
  <div className="flex gap-6 border-b border-gray-200 dark:border-gray-700 mb-4">
    {(["plans", "feedback"] as const).map((tab) => (
      <button key={tab} onClick={() => setActiveTab(tab)}
        className={`pb-2 text-sm font-medium capitalize transition-colors ${
          activeTab === tab
            ? "border-b-2 border-brand-600 text-brand-600"
            : "text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200"
        }`}>
        {tab === "plans" ? "Plans" : "Feedback"}
      </button>
    ))}
  </div>
  ```
- Existing plans list + toolbar render only when `activeTab === "plans"`
- When `activeTab === "feedback"`: render `<FeedbackInbox orgId={orgId} />`
  where `orgId` is resolved from the existing `membership.org_id` already loaded in `loadData`
- Store orgId in state: `const [orgId, setOrgId] = useState<string | null>(null)`
- Set it alongside clients load in `loadData`
- Ensure `FeedbackInbox` is conditionally rendered only when `activeTab === "feedback"` (lazy mount — no fetch until tab is activated)

**TypeScript:** Use `as any` for Supabase nested join types as needed (established pattern).
  </action>
  <verify>
    <automated>cd "C:/Users/Troy Morgan/OneDrive/coach-os/apps/trainer-web" && npx tsc --noEmit 2>&1 | tail -10</automated>
  </verify>
  <done>All files exist. TypeScript compiles with zero errors. /nutrition page renders with "Plans" and "Feedback" tabs. Clicking Feedback tab renders FeedbackInbox (may show empty state if no feedback exists). DraftReviewModal file exists and imports cleanly.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors across all 4 new files
- `/nutrition` page has two tabs: Plans and Feedback
- GET /api/nutrition/feedback returns 401 without auth
- DraftReviewModal renders in the feedback tab when a feedback item is selected
</verification>

<success_criteria>
Coach can navigate to /nutrition → Feedback tab, see pending feedback items, click "Get AI Draft", see the modal with original vs suggested swap, and click "Approve" or "Reject".
</success_criteria>

<output>
After completion, create `.planning/phases/09-ai-feedback-loop-versioning/09-03-SUMMARY.md`
</output>
