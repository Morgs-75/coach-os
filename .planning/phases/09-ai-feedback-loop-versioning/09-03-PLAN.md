---
phase: 09-ai-feedback-loop-versioning
plan: "03"
type: execute
wave: 3
depends_on:
  - "09-02"
files_modified:
  - apps/trainer-web/src/app/api/nutrition/feedback/route.ts
  - apps/trainer-web/src/app/(app)/nutrition/FeedbackInbox.tsx
  - apps/trainer-web/src/app/(app)/nutrition/DraftReviewModal.tsx
  - apps/trainer-web/src/app/(app)/nutrition/NutritionClient.tsx
autonomous: true
requirements:
  - FEEDBACK-VERSIONING-04
  - FEEDBACK-VERSIONING-05
must_haves:
  truths:
    - "Coach can see a list of pending feedback items in the /nutrition section with client name, meal, feedback type, and comment"
    - "Coach can click a feedback item and trigger AI draft — a loading state shows while Claude processes"
    - "Draft review modal shows: original food name + qty vs AI-suggested food name + qty + reasoning"
    - "Coach can edit the AI suggestion before approving — override qty_g with a number input and override food name via a text search input"
    - "Coach can accept the draft (with any edits applied — creates new version) or reject it (marks reviewed without versioning)"
    - "After approve, a success state confirms new version published"
  artifacts:
    - path: "apps/trainer-web/src/app/api/nutrition/feedback/route.ts"
      provides: "GET handler returning pending feedback items with joined meal + client + plan data"
      exports: ["GET"]
    - path: "apps/trainer-web/src/app/(app)/nutrition/FeedbackInbox.tsx"
      provides: "Feedback list component showing pending items with Draft button"
      min_lines: 80
    - path: "apps/trainer-web/src/app/(app)/nutrition/DraftReviewModal.tsx"
      provides: "Modal: original vs AI swap comparison + optional edit inputs + accept/reject actions"
      min_lines: 130
  key_links:
    - from: "FeedbackInbox.tsx (Draft button)"
      to: "POST /api/nutrition/feedback/[id]/draft"
      via: "fetch call on button click"
      pattern: "fetch.*feedback.*draft"
    - from: "DraftReviewModal.tsx (Approve button)"
      to: "POST /api/nutrition/plans/[planId]/version"
      via: "fetch with component_id + new_food_item_id + new_qty_g (using overrides if set)"
      pattern: "fetch.*plans.*version"
---

<objective>
Build the coach feedback inbox and draft review modal in the `/nutrition` section. Coach can see pending feedback, trigger AI draft, review the swap (and optionally edit the qty or food name before approving), then approve to publish a new version.

Purpose: This is the coach-facing workflow that drives the feedback loop — the reason Phase 9 exists. The phase goal explicitly states "coach approves/edits" so the modal must support editing the AI suggestion, not just accepting or rejecting it.

Output: `FeedbackInbox.tsx`, `DraftReviewModal.tsx`, GET feedback API, wired into `NutritionClient.tsx` as a new tab.
</objective>

<execution_context>
@C:/Users/Troy Morgan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Troy Morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-ai-feedback-loop-versioning/09-02-SUMMARY.md

<interfaces>
<!-- NutritionClient.tsx current structure (from Phase 6 — has tabs pattern we'll extend): -->
```typescript
// Current: single view showing meal plans list
// Phase 9: add "Feedback" tab alongside "Plans" tab
// Tab state pattern: const [activeTab, setActiveTab] = useState<"plans" | "feedback">("plans")
// NutritionClient already imports createClient and has org/user loading
// The feedback inbox component receives orgId as prop (NutritionClient resolves it)
```

<!-- GET /api/nutrition/feedback — new endpoint: -->
```typescript
// Query: meal_plan_feedback table
// Select: id, plan_id, meal_id, client_id, type, scope, comment, forward, status, created_at,
//         ai_draft_food_item_id, ai_draft_qty_g, ai_draft_reasoning
// Join: plan:meal_plans(id, name, version, client:clients(id, name, first_name, last_name)),
//       meal:meal_plan_meals(id, meal_type, title)
// Filter: feedback rows where plan.org_id = orgId (via EXISTS subquery)
// Default: status = 'pending' (query param ?status=all to include reviewed)
// Order: created_at DESC
// Returns: { feedback: FeedbackItem[] }
```

<!-- POST /api/nutrition/feedback/[id]/draft (from Plan 02): -->
```typescript
// Returns: { draft: { food_item_id, food_item_name, qty_g, reasoning, component_id } }
// Also updates meal_plan_feedback.ai_draft_* columns
```

<!-- GET /api/nutrition/feedback/[id] (from Plan 02): -->
```typescript
// Returns feedback row with original component + ai_draft food item details
// We need: original food name + qty, and ai_draft food item name + qty + reasoning
```

<!-- POST /api/nutrition/plans/[planId]/version (from Plan 02): -->
```typescript
// Body: { component_id: string, new_food_item_id: string, new_qty_g: number, feedback_id: string }
// Returns: { plan: { id: string, version: number } }
```

<!-- GET /api/nutrition/foods?q= (from Phase 6): -->
```typescript
// Returns: { foods: [{ id, food_name, food_group, energy_kcal, protein_g, fat_g, carb_g }] }
// Used in DraftReviewModal food name override search
```

<!-- DraftReviewModal state machine: -->
// States: idle | drafting | draft_ready | approving | approved | rejected | error
// idle → drafting: coach clicks "Get AI Draft"
// drafting → draft_ready: Claude response received, draft stored in feedback row
// draft_ready → approving: coach clicks "Approve & Publish"
// approving → approved: version endpoint returns success
// draft_ready → rejected: coach clicks "Reject" (PATCH feedback status=reviewed)
// any → error: API call failed

<!-- Existing NutritionClient.tsx tab pattern (established in Phase 8 portal): -->
// Tab bar with brand-600 underline on active tab
// Tabs inside top div, content conditionally rendered below
// Pattern from PortalDashboard.tsx Phase 8 for reference
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Feedback list API + FeedbackInbox component</name>
  <files>
    apps/trainer-web/src/app/api/nutrition/feedback/route.ts
    apps/trainer-web/src/app/(app)/nutrition/FeedbackInbox.tsx
  </files>
  <action>
**1. Create `src/app/api/nutrition/feedback/route.ts` — GET handler:**

```typescript
import { NextResponse } from "next/server";
import { createClient } from "@/lib/supabase/server";

// getOrgAndUser helper (same pattern as other nutrition routes)

export async function GET(request: Request) {
  // Auth: get org
  // Parse ?status=all query param (default: only pending)
  // Query meal_plan_feedback with joins:
  //   SELECT feedback.*, plan:meal_plans!inner(id, name, version, client_id,
  //     client:clients(id, name, first_name, last_name)),
  //     meal:meal_plan_meals(id, meal_type, title)
  //   WHERE EXISTS (SELECT 1 FROM meal_plans mp JOIN org_members om ON om.org_id = mp.org_id
  //     WHERE mp.id = meal_plan_feedback.plan_id AND om.user_id = auth.uid())
  //
  // Implementation: use Supabase .from("meal_plan_feedback").select(`
  //   *, plan:meal_plans!inner(id, name, version, client:clients(id, name, first_name, last_name)),
  //   meal:meal_plan_meals(id, meal_type, title)
  // `)
  // .eq("plan.org_id", orgId)  ← this filters via the inner join
  // If status !== 'all': .eq("status", "pending")
  // .order("created_at", { ascending: false })
  //
  // Note: Supabase may not support .eq on a joined column directly.
  // Alternative safe query: load all feedback ids where plan.org_id = orgId via a subquery first:
  //   const { data: planIds } = await supabase.from("meal_plans").select("id").eq("org_id", orgId)
  //   then .in("plan_id", planIds.map(p => p.id))
  // Use this two-step approach (same pattern as Phase 8 portal two-step plan fetch)
  //
  // Return: { feedback: data ?? [] }
}
```

**2. Create `src/app/(app)/nutrition/FeedbackInbox.tsx` — client component:**

```typescript
"use client";
// Props: { orgId: string }
// State: items (FeedbackItem[]), loading, selectedItem (FeedbackItem | null), showDraftModal

interface FeedbackItem {
  id: string;
  plan_id: string;
  meal_id: string | null;
  client_id: string;
  type: string;
  scope: string;
  comment: string | null;
  status: "pending" | "reviewed";
  ai_draft_food_item_id: string | null;
  ai_draft_qty_g: number | null;
  ai_draft_reasoning: string | null;
  created_at: string;
  plan: { id: string; name: string; version: number; client: { id: string; name: string | null; first_name?: string | null; last_name?: string | null } | null };
  meal: { id: string; meal_type: string; title: string | null } | null;
}

// Load on mount via GET /api/nutrition/feedback
// Render: table with columns: Client | Plan | Meal | Type | Scope | Comment | Date | Action
// Each row shows:
//   - Client name (clientDisplayName helper)
//   - Plan name + version badge (e.g. "7-Day Plan v1")
//   - Meal type label (e.g. "Lunch") or "Plan-level" if meal_id is null
//   - Type badge (color-coded: substitution=blue, dislike=orange, allergy=red, other=gray)
//   - Scope (this_meal / going_forward / all_occurrences — formatted as readable label)
//   - Comment (truncated to 60 chars with title tooltip for full text)
//   - Date (formatted en-AU)
//   - "Get AI Draft" button (primary, disabled if meal_id is null — draft requires meal context)
//     OR if ai_draft_food_item_id already set: "Review Draft" button (secondary)
// Empty state: "No pending feedback" with gray border dashed card
// Pass selectedItem to <DraftReviewModal> and toggle modal open on button click
// On modal close / approved: reload the feedback list
```

FeedbackInbox should import DraftReviewModal and render it alongside the list (not inline).
  </action>
  <verify>
    <automated>cd "C:/Users/Troy Morgan/OneDrive/coach-os/apps/trainer-web" && npx tsc --noEmit 2>&1 | tail -5</automated>
  </verify>
  <done>Files exist. TypeScript compiles clean. GET /api/nutrition/feedback returns 401 without auth. FeedbackInbox renders with correct columns and "No pending feedback" empty state.</done>
</task>

<task type="auto">
  <name>Task 2: DraftReviewModal with edit override inputs + wire NutritionClient tabs</name>
  <files>
    apps/trainer-web/src/app/(app)/nutrition/DraftReviewModal.tsx
    apps/trainer-web/src/app/(app)/nutrition/NutritionClient.tsx
  </files>
  <action>
**1. Create `DraftReviewModal.tsx`:**

```typescript
"use client";
// Props: { item: FeedbackItem | null, open: boolean, onClose: () => void, onApproved: () => void }
// Modal: fixed inset overlay (bg-black/50 z-50 flex items-center justify-center)
// Content card: max-w-lg, rounded-xl, bg-white dark:bg-gray-900, p-6

// State machine: idle | drafting | draft_ready | approving | approved | rejected | error
// Initial state: if item.ai_draft_food_item_id is already set → draft_ready; else → idle

// Additional edit state (active only in draft_ready):
// - overrideQtyG: number | null  (null = use AI suggestion as-is)
// - overrideFoodItemId: string | null
// - overrideFoodItemName: string | null
// - foodSearchQuery: string  (controlled input for food name search)
// - foodSearchResults: FoodSearchResult[]
// - foodSearchLoading: boolean

interface FoodSearchResult {
  id: string;
  food_name: string;
  food_group: string | null;
}
```

**State machine states:**

**idle state:**
- "Get AI Draft" primary button → triggers POST /api/nutrition/feedback/[id]/draft
- Shows item summary: feedback type, comment, meal name

**drafting state:**
- Spinner + "Claude is generating a suggestion..."

**draft_ready state (after draft returned or item already has ai_draft_*):**

Two-column comparison table:
```
| | Original | AI Suggestion |
| Food | {original_food_name} | {overrideFoodItemName ?? ai_draft_food_name} |
| Qty  | {original_qty_g}g    | {overrideQtyG ?? ai_draft_qty_g}g           |
```

Reasoning box: gray bg, italic text, Claude's reasoning (from ai_draft_reasoning).

**Edit override section** — collapsible (disclosure pattern, default closed — label "Edit AI suggestion"):
```tsx
// Qty override: number input, min=1, max=2000, step=1
// Label: "Override quantity (g)"
// Placeholder: {ai_draft_qty_g}
// Value: overrideQtyG ?? ""
// onChange: setOverrideQtyG(Number(e.target.value) || null)

// Food override: text input with live search (debounced 300ms) against GET /api/nutrition/foods?q=
// Label: "Override food (search AFCD)"
// Renders a small dropdown list of foodSearchResults below the input when non-empty
// On selecting a result: setOverrideFoodItemId(result.id), setOverrideFoodItemName(result.food_name),
//   clear foodSearchResults + foodSearchQuery
// Show current override as a chip with an × to clear it
```

The comparison table updates in real-time as the coach makes overrides (controlled values).

**Action buttons (in draft_ready state):**
- "Approve & Publish New Version" (green, primary):
  - Calls POST /api/nutrition/plans/[planId]/version with:
    - `component_id`: from draft response (stored in local state)
    - `new_food_item_id`: overrideFoodItemId ?? draft.food_item_id
    - `new_qty_g`: overrideQtyG ?? draft.qty_g
    - `feedback_id`: item.id
  - Transitions to approving → approved on success
- "Reject" (outline gray):
  - PATCH /api/nutrition/feedback/[item.id] { status: "reviewed" }
  - Transitions to rejected

**For original component data** (needed in the comparison table):
After POST /draft returns `{ draft: { component_id, food_item_id, food_item_name, qty_g, reasoning } }`,
make a second call GET /api/nutrition/feedback/[id] which returns the feedback row with component join.
Store `originalComponent: { food_name, qty_g }` in local state from that response.
For plans where ai_draft already exists (item enters in draft_ready state), fetch GET on modal open.

**approving state:** Spinner + "Publishing new version..."

**approved state:**
- Green checkmark + "New version published!"
- "Version v{newVersion} is now live in the client portal."
- "Done" button → calls onApproved() + onClose()

**rejected state:**
- "Feedback marked as reviewed." + Close button

**error state:**
- Red banner with error message + "Try Again" button (resets to idle or draft_ready)

**2. Modify `NutritionClient.tsx` — add Feedback tab:**

- Add `activeTab` state: `useState<"plans" | "feedback">("plans")`
- Add tab bar below the page title / above the toolbar:
  ```tsx
  <div className="flex gap-6 border-b border-gray-200 dark:border-gray-700 mb-4">
    {(["plans", "feedback"] as const).map((tab) => (
      <button key={tab} onClick={() => setActiveTab(tab)}
        className={`pb-2 text-sm font-medium capitalize transition-colors ${
          activeTab === tab
            ? "border-b-2 border-brand-600 text-brand-600"
            : "text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200"
        }`}>
        {tab === "plans" ? "Plans" : "Feedback"}
      </button>
    ))}
  </div>
  ```
- Existing plans list + toolbar render only when `activeTab === "plans"`
- When `activeTab === "feedback"`: render `<FeedbackInbox orgId={orgId} />`
  where `orgId` is resolved from the existing `membership.org_id` already loaded in `loadData`
- Store orgId in state: `const [orgId, setOrgId] = useState<string | null>(null)`
- Set it alongside clients load in `loadData`
- Ensure `FeedbackInbox` is conditionally rendered only when `activeTab === "feedback"` (lazy mount — no fetch until tab is activated)

**TypeScript:** Use `as any` for Supabase nested join types as needed (established pattern).
  </action>
  <verify>
    <automated>cd "C:/Users/Troy Morgan/OneDrive/coach-os/apps/trainer-web" && npx tsc --noEmit 2>&1 | tail -10</automated>
  </verify>
  <done>All files exist. TypeScript compiles with zero errors. /nutrition page renders with "Plans" and "Feedback" tabs. Clicking Feedback tab renders FeedbackInbox. DraftReviewModal shows "Edit AI suggestion" disclosure with qty override input and food name search input in draft_ready state.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors across all 4 new files
- `/nutrition` page has two tabs: Plans and Feedback
- GET /api/nutrition/feedback returns 401 without auth
- DraftReviewModal renders in the feedback tab when a feedback item is selected
- DraftReviewModal draft_ready state shows editable qty_g override input and food search override input
- Approve button passes overrideQtyG and overrideFoodItemId to the version endpoint when set
</verification>

<success_criteria>
Coach can navigate to /nutrition → Feedback tab, see pending feedback items, click "Get AI Draft", see the modal with original vs suggested swap, optionally edit the qty or food name, and click "Approve" or "Reject". Modified values are passed to the version endpoint.
</success_criteria>

<output>
After completion, create `.planning/phases/09-ai-feedback-loop-versioning/09-03-SUMMARY.md`
</output>
