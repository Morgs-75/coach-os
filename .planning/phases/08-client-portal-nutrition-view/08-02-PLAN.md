---
phase: 08-client-portal-nutrition-view
plan: "02"
type: execute
wave: 2
depends_on:
  - "08-01"
files_modified:
  - apps/trainer-web/src/app/api/portal/nutrition/route.ts
  - apps/trainer-web/src/app/api/portal/nutrition/feedback/route.ts
autonomous: true
requirements:
  - PORTAL-NUTRITION-02
must_haves:
  truths:
    - "GET /api/portal/nutrition?token=X returns the client's active published plan with nested days/meals/components"
    - "GET returns null plan (not error) when no published plan exists for this client"
    - "POST /api/portal/nutrition/feedback inserts a row into meal_plan_feedback and sends SMS to coach"
  artifacts:
    - path: "apps/trainer-web/src/app/api/portal/nutrition/route.ts"
      provides: "GET portal nutrition endpoint"
      exports: ["GET"]
    - path: "apps/trainer-web/src/app/api/portal/nutrition/feedback/route.ts"
      provides: "POST feedback submission endpoint"
      exports: ["POST"]
  key_links:
    - from: "GET /api/portal/nutrition"
      to: "meal_plans (status=published, client_id matches token)"
      via: "createServiceClient() + portal_token lookup"
      pattern: "createServiceClient"
    - from: "POST /api/portal/nutrition/feedback"
      to: "meal_plan_feedback INSERT"
      via: "service role client"
      pattern: "supabase.from.*meal_plan_feedback.*insert"
    - from: "POST /api/portal/nutrition/feedback"
      to: "Twilio SMS to coach notify_phone"
      via: "twilioClient.messages.create"
      pattern: "twilioClient.messages.create"
---

<objective>
Build two portal API routes: one to fetch the client's published meal plan, one to submit feedback. Both use the same token-auth pattern as existing portal routes.

Purpose: The portal UI (Plan 03) calls these endpoints. They must exist and work before the UI is built.
Output: Two route files that the nutrition view and feedback drawer can call.
</objective>

<execution_context>
@C:/Users/Troy Morgan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Troy Morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md

<interfaces>
<!-- Portal auth pattern — copy from existing portal routes exactly -->

// createServiceClient from "@/lib/supabase/service"
// Token resolution:
//   const { data: client } = await supabase
//     .from("clients")
//     .select("id, full_name, org_id")
//     .eq("portal_token", token)
//     .single();
//   if (!client) return NextResponse.json({ error: "Invalid link" }, { status: 401 });

// meal_plans shape returned by GET /api/nutrition/plans/[planId]:
// {
//   id, org_id, client_id, name, start_date, end_date, status, version, published_at,
//   days: Array<{
//     id, plan_id, day_number, date,
//     meals: Array<{
//       id, day_id, meal_type, title, note, sort_order,
//       components: Array<{
//         id, meal_id, food_item_id, qty_g, custom_name, sort_order,
//         food_item: { id, food_name, food_group, energy_kcal, protein_g, fat_g, carb_g, fibre_g } | null
//       }>
//     }>
//   }>
// }

// meal_plan_feedback INSERT shape:
// { plan_id, meal_id (nullable), client_id, type, scope, comment (nullable), forward (nullable), status: 'pending' }

// Twilio notification pattern (from create-booking/route.ts):
//   import twilio from "twilio"
//   const twilioClient = twilio(process.env.TWILIO_ACCOUNT_SID, process.env.TWILIO_AUTH_TOKEN)
//   const { data: settings } = await supabase.from("booking_settings").select("notify_phone").eq("org_id", client.org_id).single()
//   const coachPhone = settings?.notify_phone
//   if (process.env.TWILIO_PHONE_NUMBER && coachPhone) {
//     await twilioClient.messages.create({ body, from: process.env.TWILIO_PHONE_NUMBER, to: coachPhone })
//   }
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: GET /api/portal/nutrition — fetch published plan for token</name>
  <files>apps/trainer-web/src/app/api/portal/nutrition/route.ts</files>
  <action>
Create `src/app/api/portal/nutrition/route.ts` with a GET handler.

Request: `GET /api/portal/nutrition?token={portalToken}`

Logic:
1. Read `token` from URL searchParams. If missing → 400.
2. Resolve client from token using `createServiceClient()` (service role). If not found → 401.
3. Query `meal_plans` for the MOST RECENT published plan assigned to this client:
   ```sql
   SELECT * FROM meal_plans
   WHERE client_id = {client.id}
     AND status = 'published'
   ORDER BY published_at DESC
   LIMIT 1
   ```
4. If no plan found → return `{ plan: null }` with 200 (NOT 404 — the portal must handle no-plan gracefully).
5. If plan found, load nested days/meals/components with food_item join:
   ```typescript
   supabase.from("meal_plans")
     .select(`
       id, name, start_date, end_date, published_at, version,
       days:meal_plan_days(
         id, day_number, date,
         meals:meal_plan_meals(
           id, meal_type, title, note, sort_order,
           components:meal_plan_components(
             id, qty_g, custom_name, sort_order,
             food_item:food_items(id, food_name, energy_kcal, protein_g, fat_g, carb_g)
           )
         )
       )
     `)
     .eq("id", plan.id)
     .single()
   ```
6. Sort days by day_number, meals by sort_order, components by sort_order (same as coach plan builder).
7. Return `{ plan: sortedPlan, clientName: client.full_name }`.

Use `createServiceClient()` throughout (service role bypasses RLS — correct for portal routes).

Error handling: wrap in try/catch, return 500 on unexpected errors.
  </action>
  <verify>
    <automated>curl -s "http://localhost:3000/api/portal/nutrition?token=INVALID_TOKEN" | grep -q '"error"' && echo "PASS: invalid token rejected" || echo "FAIL"</automated>
  </verify>
  <done>GET /api/portal/nutrition?token=X returns { plan: {...}, clientName: "..." } when a published plan exists for the client, or { plan: null, clientName: "..." } when none exists. Invalid/missing token returns 401.</done>
</task>

<task type="auto">
  <name>Task 2: POST /api/portal/nutrition/feedback — submit feedback + notify coach</name>
  <files>apps/trainer-web/src/app/api/portal/nutrition/feedback/route.ts</files>
  <action>
Create `src/app/api/portal/nutrition/feedback/route.ts` with a POST handler.

Request body:
```typescript
{
  token: string;          // portal_token
  plan_id: string;        // meal_plans.id
  meal_id?: string;       // meal_plan_meals.id (nullable — feedback can be plan-level)
  type: 'substitution' | 'dislike' | 'allergy' | 'portion' | 'schedule' | 'other';
  scope: 'this_meal' | 'going_forward' | 'all_occurrences';
  comment?: string;
  forward?: 'yes' | 'no' | 'ask_me';
}
```

Logic:
1. Parse body. Validate required fields: token, plan_id, type, scope. If missing → 400.
2. Resolve client from token using `createServiceClient()`. If not found → 401.
3. Verify plan_id belongs to this client AND is published:
   ```typescript
   const { data: plan } = await supabase.from("meal_plans")
     .select("id, org_id, client_id")
     .eq("id", plan_id)
     .eq("client_id", client.id)
     .eq("status", "published")
     .single();
   if (!plan) return 403 "Plan not found or not accessible"
   ```
4. INSERT into `meal_plan_feedback`:
   ```typescript
   await supabase.from("meal_plan_feedback").insert({
     plan_id,
     meal_id: meal_id ?? null,
     client_id: client.id,
     type,
     scope,
     comment: comment ?? null,
     forward: forward ?? null,
     status: 'pending',
   })
   ```
5. Send Twilio SMS to coach (same pattern as create-booking/cancel-booking):
   - Fetch `booking_settings.notify_phone` for `client.org_id`
   - If `TWILIO_PHONE_NUMBER` and `notify_phone` exist:
     ```
     "{client.full_name} submitted nutrition feedback on their meal plan: {type} — {comment truncated to 80 chars}"
     ```
   - Wrap in try/catch — SMS failure must NOT fail the endpoint (return 201 either way).
6. Return `{ success: true }` with 201.

Note: Service role is used for INSERT so RLS does not block the portal write. This matches the pattern used by create-booking.
  </action>
  <verify>
    <automated>curl -s -X POST http://localhost:3000/api/portal/nutrition/feedback -H "Content-Type: application/json" -d '{"token":"bad","plan_id":"x","type":"dislike","scope":"this_meal"}' | grep -q '"error"' && echo "PASS: bad token rejected" || echo "FAIL"</automated>
  </verify>
  <done>POST with valid token + plan_id inserts a row in meal_plan_feedback and returns { success: true, id: uuid }. POST with invalid token returns 401. POST missing required fields returns 400. Coach SMS fires (or silently skips if Twilio not configured).</done>
</task>

</tasks>

<verification>
- `curl http://localhost:3000/api/portal/nutrition?token=BAD` → 401
- `curl http://localhost:3000/api/portal/nutrition?token=VALID_TOKEN` → { plan: {...} } or { plan: null }
- POST to /api/portal/nutrition/feedback with valid token → { success: true } + row in meal_plan_feedback
- TypeScript compiles with no errors: `cd apps/trainer-web && npx tsc --noEmit`
</verification>

<success_criteria>
Two portal API routes exist and handle the full request/response cycle. Data flows from token → client → plan correctly. Feedback rows land in the DB. Coach SMS fires on feedback submission.
</success_criteria>

<output>
After completion, create `.planning/phases/08-client-portal-nutrition-view/08-02-SUMMARY.md`
</output>
