---
phase: 04-ui-reliability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/trainer-web/src/app/(app)/clients/[id]/page.tsx
autonomous: false
requirements:
  - UI-01

must_haves:
  truths:
    - "If bookings fail to load, the sessions section shows 'Couldn't load bookings. Try again' in place of the spinner/blank"
    - "If purchases/package data fail to load, the sessions-remaining section shows 'Couldn't load package info. Try again'"
    - "If the client profile query fails, the page shows a page-level error rather than a blank page"
    - "If notes/comms fail to load, those sections show 'Couldn't load notes. Try again'"
    - "Error states are visually distinct from empty states — different color or icon (amber/red vs grey)"
    - "Sections that load successfully show data normally — unaffected by a sibling section's failure"
    - "Clicking 'Try again' in an error section re-fetches only that section's data"
  artifacts:
    - path: "apps/trainer-web/src/app/(app)/clients/[id]/page.tsx"
      provides: "Per-section error states with retry for 4 critical sections"
      contains: "sectionError"
  key_links:
    - from: "loadClient() monolithic fetch"
      to: "individual per-section fetch functions"
      via: "split loadClient into loadClientProfile, loadBookings, loadPurchases, loadNotes"
      pattern: "sectionError\\.(bookings|purchases|profile|notes)"
    - from: "error state JSX"
      to: "retry handler"
      via: "onClick calls individual fetch function"
      pattern: "Try again"
---

<objective>
Add per-section inline error states with retry to the four critical sections on the client detail page.

Purpose: When a DB query fails, trainers currently see a blank section with no indication something went wrong. They may assume the client has no data, or not notice at all. Visible errors with retry let them know what broke and recover without a full page refresh.

Output: Modified clients/[id]/page.tsx with per-section error tracking state, individual fetch functions for each critical section, and inline error UI (amber warning icon + section-specific message + "Try again" link) that is visually distinct from empty states.
</objective>

<execution_context>
@C:/Users/Troy Morgan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Troy Morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/04-ui-reliability/04-CONTEXT.md

Key file: apps/trainer-web/src/app/(app)/clients/[id]/page.tsx

Current state of the file (key facts):
- Line 60: `export default function ClientDetailPage()`
- Lines 63–134: All section data stored in flat state (client, activities, messages, payments, clientBookings, clientPurchases, communications, waivers)
- Line 75: Single `loading` boolean — page-level only, no per-section loading/error state
- Lines 156–158: `useEffect(() => { loadClient(); }, [clientId])`
- Lines 160–351: `loadClient()` — monolithic async function running all DB queries sequentially with no error capture. Pattern: `const { data: X } = await supabase.from(...)` — errors are silently discarded
- Line 1168: `if (loading) return <div>Loading...</div>` — single loading guard
- Line 1172: `if (!client) return <div>Client not found</div>` — already handles missing client at page level
- Lines 1396–1453: Sessions section (overview tab) — renders `clientBookings` — no error state
- Lines 1481–1516: Package summary section (overview sidebar) — renders `clientPurchases` + `upcomingBookingCount` — no error state
- Lines 1518–1533: Contact section — renders `client.*` fields — data always present if page loaded
- Notes section is in the profile tab (not overview) — communications via `communications` state

Four critical sections from CONTEXT.md:
1. Upcoming bookings (clientBookings) — sessions section overview tab
2. Package / sessions remaining (clientPurchases + upcomingBookingCount)
3. Notes / history (communications)
4. Client profile / contact info (client — page-level if this fails)

Design decisions (from 04-CONTEXT.md — locked):
- Errors appear INLINE inside the section — error replaces section content including spinner
- Display a WARNING ICON + short section-specific message
- Error states are VISUALLY DISTINCT from empty states — use amber background/text for errors, grey for empty
- Each error state includes a "Try again" clickable link inline: "Couldn't load bookings. Try again"
- If entire page load fails (client profile query), show PAGE-LEVEL error (not 4 individual errors)
- Sections are INDEPENDENT — failed section does not affect other sections
- Log real errors to console only — show friendly message to trainer
- Sections that load successfully show data normally
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add per-section error state and split monolithic loadClient into individual fetch functions</name>
  <files>apps/trainer-web/src/app/(app)/clients/[id]/page.tsx</files>
  <action>
The goal is to give each critical section its own error flag so a single fetch failure surfaces visibly without cascading to other sections.

**Step 1 — Add sectionError state** (near line 75, after the existing `loading` state declaration):

```tsx
const [sectionError, setSectionError] = useState<{
  profile: boolean;
  bookings: boolean;
  purchases: boolean;
  notes: boolean;
}>({ profile: false, bookings: false, purchases: false, notes: false });
```

**Step 2 — Create individual fetch functions** to replace the relevant portions of `loadClient()`. Add these as named async functions inside the component, alongside the existing monolithic `loadClient`:

```tsx
async function loadBookings() {
  setSectionError(prev => ({ ...prev, bookings: false }));
  const { data, error } = await supabase
    .from("bookings")
    .select("id, start_time, end_time, duration_mins, session_type, status, notes")
    .eq("client_id", clientId)
    .order("start_time", { ascending: false })
    .limit(50);
  if (error) {
    console.error("Error loading bookings:", error);
    setSectionError(prev => ({ ...prev, bookings: true }));
    return;
  }
  if (data) setClientBookings(data);

  const { data: upcomingData, error: upcomingError } = await supabase
    .from("bookings")
    .select("id")
    .eq("client_id", clientId)
    .neq("status", "cancelled")
    .gt("start_time", new Date().toISOString());
  if (upcomingError) {
    console.error("Error loading upcoming count:", upcomingError);
    setSectionError(prev => ({ ...prev, bookings: true }));
    return;
  }
  setUpcomingBookingCount(upcomingData?.length ?? 0);
}

async function loadPurchases() {
  setSectionError(prev => ({ ...prev, purchases: false }));
  const { data, error } = await supabase
    .from("client_purchases")
    .select("*, offers(name, offer_type, sessions_included, bonus_sessions)")
    .eq("client_id", clientId)
    .order("purchased_at", { ascending: false });
  if (error) {
    console.error("Error loading purchases:", error);
    setSectionError(prev => ({ ...prev, purchases: true }));
    return;
  }
  if (data) setClientPurchases(data);
}

async function loadNotes() {
  setSectionError(prev => ({ ...prev, notes: false }));
  const { data, error } = await supabase
    .from("client_communications")
    .select("*")
    .eq("client_id", clientId)
    .order("created_at", { ascending: false });
  if (error) {
    console.error("Error loading notes/communications:", error);
    setSectionError(prev => ({ ...prev, notes: true }));
    return;
  }
  if (data) setCommunications(data);
}
```

**Step 3 — Update `loadClient()` to call these individual functions** instead of inlining the queries. Specifically:

- Keep the existing client profile query (lines ~162-184) in `loadClient()`. Add error destructuring: `const { data: clientData, error: profileError } = await supabase.from("clients")...`. If `profileError`, set `setSectionError(prev => ({ ...prev, profile: true }))` and `setLoading(false); return;`.
- Replace the bookings queries (lines ~232-249) with a call to `loadBookings()`.
- Replace the purchases query (lines ~298-304) with a call to `loadPurchases()`.
- Replace the communications query (lines ~306-313) with a call to `loadNotes()`.
- Keep all other queries (activity, messages, payments, measurements, offers, waivers, referrals, newsletters) inline in `loadClient()` — they are not critical sections requiring per-section error states.

**Step 4 — Update the useEffect** to call `loadClient()` as before (no change needed here — loadClient now calls the individual functions internally).
  </action>
  <verify>
    <automated>cd "C:/Users/Troy Morgan/OneDrive/coach-os" && npx tsc --noEmit -p apps/trainer-web/tsconfig.json 2>&1 | head -20</automated>
    <manual>Check that the file compiles without TypeScript errors and sectionError state is present</manual>
  </verify>
  <done>TypeScript compiles clean. File contains `sectionError` state object with profile/bookings/purchases/notes keys. loadClient calls loadBookings(), loadPurchases(), loadNotes() as separate functions. Each function has error destructuring and sets sectionError flag on failure.</done>
</task>

<task type="auto">
  <name>Task 2: Add inline error UI to the four critical sections</name>
  <files>apps/trainer-web/src/app/(app)/clients/[id]/page.tsx</files>
  <action>
Add inline error JSX to each critical section. All error states use amber styling to be visually distinct from empty states (which use grey/muted text).

**Error state helper** — add a small inline helper component near the top of the return JSX (or as a local const inside the component after the `if (!client)` guard):

```tsx
function SectionError({ message, onRetry }: { message: string; onRetry: () => void }) {
  return (
    <div className="flex items-center gap-2 text-sm text-amber-700 bg-amber-50 border border-amber-200 rounded-lg px-4 py-3">
      <svg className="w-4 h-4 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
      </svg>
      <span>
        {message}{" "}
        <button onClick={onRetry} className="underline font-medium hover:text-amber-900">
          Try again
        </button>
      </span>
    </div>
  );
}
```

Place this as a nested function inside `ClientDetailPage` (before the return statement), OR as a module-level function above the component — either works, match existing code style.

**Page-level error** — update the `if (!client)` guard (line ~1172) to also handle the profile error case:

```tsx
if (!client) {
  if (sectionError.profile) {
    return (
      <div className="flex items-center gap-3 text-amber-700 bg-amber-50 border border-amber-200 rounded-lg px-6 py-4 mt-8">
        <svg className="w-5 h-5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
        </svg>
        <span>
          Couldn&apos;t load client details.{" "}
          <button onClick={loadClient} className="underline font-medium hover:text-amber-900">Try again</button>
        </span>
      </div>
    );
  }
  return <div className="text-gray-500 dark:text-gray-400">Client not found</div>;
}
```

**Sessions section** (overview tab, around line 1396-1453) — wrap with error check:

Replace the opening `{clientBookings.length > 0 && (() => {` conditional with:

```tsx
{sectionError.bookings ? (
  <div className="card p-6">
    <h3 className="font-semibold text-gray-900 dark:text-gray-100 mb-3">Sessions</h3>
    <SectionError message="Couldn't load bookings." onRetry={loadBookings} />
  </div>
) : clientBookings.length > 0 && (() => {
  // ... existing sessions render code unchanged ...
})()}
```

**Package summary section** (overview sidebar, around line 1481-1516) — wrap the existing IIFE:

```tsx
{sectionError.purchases ? (
  <div className="card p-6">
    <h3 className="font-semibold text-gray-900 dark:text-gray-100 mb-3">Sessions</h3>
    <SectionError message="Couldn't load package info." onRetry={loadPurchases} />
  </div>
) : (() => {
  // ... existing package summary IIFE unchanged ...
})()}
```

**Notes/communications section** — Find where `communications` renders (in the comms tab or overview). Wrap with:

```tsx
{sectionError.notes ? (
  <SectionError message="Couldn't load notes." onRetry={loadNotes} />
) : (
  // ... existing communications render ...
)}
```

**Important implementation notes:**
- Do NOT change empty-state rendering for sections that have zero data but loaded successfully — those stay as-is (grey/muted, different from error)
- Do NOT restyle or restructure any sections beyond adding the error wrapping
- Do NOT add error states to non-critical sections (activity, messages, payments, measurements, waivers, etc.)
- The `SectionError` component uses amber (`amber-50` bg, `amber-700` text, `amber-200` border) — clearly different from empty states which use grey text
- Preserve all existing className patterns and code style
  </action>
  <verify>
    <automated>cd "C:/Users/Troy Morgan/OneDrive/coach-os" && npx tsc --noEmit -p apps/trainer-web/tsconfig.json 2>&1 | head -20</automated>
    <manual>Grep check that error UI is wired up</manual>
  </verify>
  <done>TypeScript compiles clean. File contains "Couldn't load bookings", "Couldn't load package info", "Couldn't load notes", "Couldn't load client details" strings. SectionError component present. sectionError.bookings / sectionError.purchases / sectionError.notes / sectionError.profile are referenced in JSX.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Human verify — inline error states on client detail page</name>
  <action>No implementation needed — this is a visual verification checkpoint after Tasks 1 and 2 are complete.</action>
  <files>apps/trainer-web/src/app/(app)/clients/[id]/page.tsx</files>
  <verify>
    <manual>
    1. Open the app and navigate to any client detail page — it should load normally with no visible change
    2. To test error states, temporarily break a query in loadBookings() (e.g., change the table name to "bookings_broken"), reload the client page — the sessions section should show amber "Couldn't load bookings. Try again" while other sections load normally
    3. Click "Try again" — the section should re-fetch and either show data or maintain the error state
    4. Verify the error state (amber warning icon + message) looks different from an empty state (which shows grey text like "No bookings yet")
    5. Revert any temporary break you introduced
    6. Confirm: TypeScript still compiles clean
    </manual>
  </verify>
  <done>Trainer can visually confirm error states appear, look distinct from empty states, and retry works</done>
  <what-built>Per-section inline error states on the client detail page. Four sections now show "Couldn't load [section]. Try again" in amber when their DB query fails. Error states are visually distinct from empty states. Sections are independent — a failed section doesn't affect siblings. Page-level error shows if the client profile query fails.</what-built>
  <how-to-verify>See verify element above</how-to-verify>
  <resume-signal>Type "approved" when sections look correct, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
grep -n "sectionError" apps/trainer-web/src/app/(app)/clients/[id]/page.tsx | head -20
grep -n "Try again" apps/trainer-web/src/app/(app)/clients/[id]/page.tsx
grep -n "Couldn't load" apps/trainer-web/src/app/(app)/clients/[id]/page.tsx
grep -n "loadBookings\|loadPurchases\|loadNotes" apps/trainer-web/src/app/(app)/clients/[id]/page.tsx | head -20
</verification>

<success_criteria>
- `sectionError` state object with profile/bookings/purchases/notes keys exists in the component
- `loadBookings()`, `loadPurchases()`, `loadNotes()` functions exist with error destructuring
- Error UI renders for each section when sectionError flag is true
- Error UI uses amber styling, distinct from empty-state grey
- "Try again" links call the individual reload function
- TypeScript compiles with no new errors
- All non-critical sections (activity, measurements, waivers, etc.) are unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/04-ui-reliability/04-01-SUMMARY.md`
</output>
