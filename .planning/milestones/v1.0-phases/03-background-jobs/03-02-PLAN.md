---
phase: 03-background-jobs
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/functions/stripe-webhook/index.ts
autonomous: true
requirements:
  - STRIPE-01

must_haves:
  truths:
    - "Delivering the same invoice.paid webhook twice does not create duplicate rows in money_events"
    - "P&L figures remain accurate when Stripe retries a webhook event"
    - "A first-time invoice.paid delivery still inserts all three money_events rows (INCOME, FEE, PLATFORM_FEE)"
  artifacts:
    - path: "supabase/functions/stripe-webhook/index.ts"
      provides: "Idempotent handleInvoicePaid with dedup check before insert"
      contains: "reference_id.*type.*INCOME"
  key_links:
    - from: "handleInvoicePaid()"
      to: "money_events table"
      via: "SELECT before INSERT — check reference_id + type = 'INCOME' to detect prior delivery"
      pattern: "reference_id.*invoice\\.id.*INCOME"
---

<objective>
Make handleInvoicePaid() idempotent by checking whether money_events rows for the same invoice already exist before inserting. Stripe can re-deliver invoice.paid on retry; without a dedup check each retry inflates P&L records.

Purpose: Financial data accuracy — duplicate webhook deliveries must not produce duplicate income, fee, and platform fee entries.
Output: Modified supabase/functions/stripe-webhook/index.ts where handleInvoicePaid skips the insert if rows for the invoice already exist.
</objective>

<execution_context>
@C:/Users/Troy Morgan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Troy Morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@supabase/functions/stripe-webhook/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add idempotency check to handleInvoicePaid (STRIPE-01)</name>
  <files>supabase/functions/stripe-webhook/index.ts</files>
  <action>
Read the current file before editing. The bug is in `handleInvoicePaid()` (lines 175-246). The function builds `moneyEvents` (three objects with `reference_id: invoice.id`) and inserts them unconditionally at line 236:
```typescript
await supabase.from("money_events").insert(moneyEvents);
```

**The fix:** Before the insert, check whether a row with `reference_id = invoice.id` AND `type = "INCOME"` already exists in `money_events`. INCOME is used as the sentinel because it is always present for every invoice.paid event — if it exists, all three rows from the prior delivery exist.

Add this block immediately before the `await supabase.from("money_events").insert(moneyEvents)` line:

```typescript
// Idempotency guard: skip insert if this invoice was already processed
const { data: existing } = await supabase
  .from("money_events")
  .select("id")
  .eq("reference_id", invoice.id)
  .eq("type", "INCOME")
  .maybeSingle();

if (existing) {
  console.log(`Invoice ${invoice.id} already recorded in money_events — skipping duplicate insert`);
  // Still update subscription status below if applicable
} else {
  await supabase.from("money_events").insert(moneyEvents);
}
```

**Important structural constraints:**
- The subscription status update block (lines 238-245) that follows the insert MUST still execute regardless of whether the insert was skipped — subscription status should always be kept current. Move or restructure so the subscription update is outside the else block.
- Do NOT change the `moneyEvents` array construction above the guard.
- Do NOT change `handleCheckoutCompleted`, `handleChargeRefunded`, `handlePayoutPaid`, or any other handler.
- Do NOT restructure the file. This is a minimum-change fix.

The resulting structure in `handleInvoicePaid` should be:
1. Get orgId — return early if none
2. Get customerId, clientId
3. Compute amounts
4. Build moneyEvents array
5. **[NEW]** Check for existing INCOME row with this invoice.id
6. **[NEW]** If no existing row: insert moneyEvents; else: log skip
7. If invoice.subscription: update subscription status (this was already here, must remain unconditional)
  </action>
  <verify>
    <automated>cd "C:/Users/Troy Morgan/OneDrive/coach-os" && grep -n "existing\|maybeSingle\|already recorded\|skipping duplicate" supabase/functions/stripe-webhook/index.ts</automated>
    <manual>Confirm: (1) a .select().eq("reference_id"...).eq("type", "INCOME").maybeSingle() call exists in handleInvoicePaid; (2) the .insert(moneyEvents) is now inside an else block; (3) the subscription update after line 238 is still present and not inside the else block.</manual>
  </verify>
  <done>
    - `existing` is selected from `money_events` by `reference_id = invoice.id` AND `type = "INCOME"` before insert
    - If `existing` is truthy, the insert is skipped and a log message is emitted
    - If `existing` is null/undefined, the insert proceeds as before
    - The subscription status update block executes regardless (not gated by the else)
    - First delivery of invoice.paid still creates all three money_events rows
    - Second delivery of the same invoice.paid creates zero new rows
  </done>
</task>

</tasks>

<verification>
After the task:
1. `grep -n "maybeSingle\|existing\|skipping duplicate" supabase/functions/stripe-webhook/index.ts` — should match lines inside handleInvoicePaid
2. `grep -n "\.insert(moneyEvents)" supabase/functions/stripe-webhook/index.ts` — should appear exactly once, inside an else block
3. `grep -n "subscriptions.*update\|update.*subscriptions" supabase/functions/stripe-webhook/index.ts` — the subscription update should still exist after the new if/else block
4. Deno type-check (if available): `deno check supabase/functions/stripe-webhook/index.ts`
</verification>

<success_criteria>
- Calling handleInvoicePaid twice with the same invoice object results in exactly 3 rows in money_events (not 6)
- The subscription status is updated to "active" on both calls (idempotent — same result both times)
- First call: inserts 3 rows and updates subscription
- Second call: skips insert, logs "already recorded", updates subscription
</success_criteria>

<output>
After completion, create `.planning/phases/03-background-jobs/03-02-SUMMARY.md`
</output>
