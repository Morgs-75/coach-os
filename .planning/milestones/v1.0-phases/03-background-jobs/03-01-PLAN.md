---
phase: 03-background-jobs
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/functions/cron-automations/index.ts
autonomous: true
requirements:
  - CRON-01
  - CRON-02

must_haves:
  truths:
    - "A weekly automation does not fire on a cron run that occurs less than 7 days after its last fire"
    - "A daily automation does not fire on a cron run that occurs less than 24 hours after its last fire"
    - "An automation whose every action succeeds is recorded with status 'ok'"
    - "An automation where at least one action throws is recorded with status 'failed', not 'ok'"
  artifacts:
    - path: "supabase/functions/cron-automations/index.ts"
      provides: "shouldTriggerFire with schedule check; executeActions with failure tracking"
      contains: "anyFailed"
  key_links:
    - from: "shouldTriggerFire()"
      to: "automation_runs table"
      via: "SELECT last fired_at for this automation to determine if schedule is due"
      pattern: "automation_runs.*fired_at"
    - from: "executeActions()"
      to: "recordRun()"
      via: "anyFailed flag threaded through processAutomation"
      pattern: "anyFailed"
---

<objective>
Fix two bugs in cron-automations/index.ts: (1) shouldTriggerFire() always returns true regardless of schedule, causing all automations to fire on every cron run; (2) executeActions() swallows action errors and always records status "ok", hiding real failures.

Purpose: Automations configured as daily/weekly should fire at most once per their configured interval. Failed actions should produce a "failed" run record so operators can see what broke.
Output: Modified supabase/functions/cron-automations/index.ts with schedule gating and failure-status recording.
</objective>

<execution_context>
@C:/Users/Troy Morgan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Troy Morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@supabase/functions/cron-automations/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement schedule gating in shouldTriggerFire (CRON-01)</name>
  <files>supabase/functions/cron-automations/index.ts</files>
  <action>
Read the current file carefully before editing. The fix is in `shouldTriggerFire()` (lines 142-155) and `processAutomation()` (lines 101-140).

The `TriggerConfig.schedule` field is typed as `string` and stores values like `"daily"` or `"weekly"` (from the interface comment at line 21). There is no `last_fired_at` column on the `automations` table row itself — instead, the last successful fire time must be read from `automation_runs` (queried by `automation_id` and `status = 'ok'`, ordered by `fired_at DESC`, limit 1).

**Change 1 — Update `shouldTriggerFire` signature:**

The function currently receives only `trigger: TriggerConfig`. It needs the last fired timestamp to gate on. Change the approach: move the schedule check into `processAutomation()` instead, where `supabase` is available. Add a helper `isScheduleDue(schedule: string, lastFiredAt: string | null): boolean` that is pure (no DB calls):

```typescript
function isScheduleDue(schedule: string, lastFiredAt: string | null): boolean {
  if (!lastFiredAt) return true; // Never fired — always due
  const now = Date.now();
  const last = new Date(lastFiredAt).getTime();
  const elapsed = now - last;
  if (schedule === "daily") return elapsed >= 24 * 60 * 60 * 1000;
  if (schedule === "weekly") return elapsed >= 7 * 24 * 60 * 60 * 1000;
  // Unknown schedule strings: fire (safe default, matches current behaviour for event triggers)
  return true;
}
```

**Change 2 — Update `processAutomation()` to fetch last fire time and gate schedule triggers:**

In `processAutomation()`, after the existing `shouldTriggerFire(automation.trigger)` call (which currently only checks `trigger.type`), add a DB lookup for scheduled automations:

```typescript
// Replace the existing shouldTriggerFire call at line 106 with:
if (automation.trigger.type === "schedule") {
  const { data: lastRun } = await supabase
    .from("automation_runs")
    .select("fired_at")
    .eq("automation_id", automation.id)
    .eq("status", "ok")
    .order("fired_at", { ascending: false })
    .limit(1)
    .maybeSingle();

  const lastFiredAt = lastRun?.fired_at ?? null;
  if (!isScheduleDue(automation.trigger.schedule ?? "", lastFiredAt)) {
    return 0;
  }
} else if (automation.trigger.type === "event") {
  // Event triggers always proceed (evaluated by conditions)
} else {
  return 0;
}
```

**Change 3 — Remove or simplify the now-unused `shouldTriggerFire()` function:**

The function at lines 142-155 is now superseded. Either delete it or replace its body with a single `return true;` comment explaining that schedule gating moved to `processAutomation`. Prefer deletion to avoid dead code — but only if no other call site exists. Grep the file to confirm before deleting.

Do NOT restructure the rest of the file. Do NOT change `getClientsWithContext`, `evaluateConditions`, `checkGuardrails`, `executeAction`, or `recordRun`.
  </action>
  <verify>
    <automated>cd "C:/Users/Troy Morgan/OneDrive/coach-os" && grep -n "isScheduleDue\|lastFiredAt\|automation_runs.*fired_at\|fired_at.*automation_runs" supabase/functions/cron-automations/index.ts</automated>
    <manual>Confirm isScheduleDue function exists, processAutomation fetches last fired_at from automation_runs, and the old always-true shouldTriggerFire is gone or dead.</manual>
  </verify>
  <done>
    - `isScheduleDue()` function exists and returns false when elapsed time is less than the schedule interval
    - `processAutomation()` queries `automation_runs` for the last `ok` run before deciding to proceed
    - A "daily" automation last fired 2 hours ago would return 0 (skip all clients)
    - A "weekly" automation last fired 8 days ago would proceed normally
  </done>
</task>

<task type="auto">
  <name>Task 2: Thread failure flag through executeActions to recordRun (CRON-02)</name>
  <files>supabase/functions/cron-automations/index.ts</files>
  <action>
Read the current file state (after Task 1 edits) before applying this change.

The bug is in `processAutomation()` at line 135:
```typescript
await recordRun(supabase, automation, client.id, "ok", null, actionResults);
```
This always passes `"ok"` even when `executeActions()` caught errors.

`executeActions()` (lines 349-366) already catches errors per action and logs them, but does not return a failure signal — it only returns the list of successfully executed actions (`executedActions`).

**Change 1 — Update `executeActions()` to return a failure indicator:**

Change the return type from `Promise<ActionConfig[]>` to `Promise<{ executed: ActionConfig[]; anyFailed: boolean }>`:

```typescript
async function executeActions(
  supabase: ReturnType<typeof createClient>,
  actions: ActionConfig[],
  client: ClientContext,
  orgId: string
): Promise<{ executed: ActionConfig[]; anyFailed: boolean }> {
  const executedActions: ActionConfig[] = [];
  let anyFailed = false;

  for (const action of actions) {
    try {
      await executeAction(supabase, action, client, orgId);
      executedActions.push(action);
    } catch (err) {
      console.error(`Action ${action.type} failed:`, err);
      anyFailed = true;
    }
  }

  return { executed: executedActions, anyFailed };
}
```

**Change 2 — Update `processAutomation()` to use the failure flag:**

Where `executeActions` is called (currently line 133):
```typescript
const actionResults = await executeActions(supabase, automation.actions, client, automation.org_id);
await recordRun(supabase, automation, client.id, "ok", null, actionResults);
```

Change to:
```typescript
const { executed: actionResults, anyFailed } = await executeActions(supabase, automation.actions, client, automation.org_id);
const runStatus = anyFailed ? "failed" : "ok";
await recordRun(supabase, automation, client.id, runStatus, anyFailed ? "One or more actions failed" : null, actionResults);
```

Do NOT change the `recordRun` function itself — its signature already accepts `"ok" | "skipped" | "failed"` (line 469). Do NOT change the `executeAction` function. Do NOT alter the try/catch structure.
  </action>
  <verify>
    <automated>cd "C:/Users/Troy Morgan/OneDrive/coach-os" && grep -n "anyFailed\|runStatus\|failed.*recordRun\|recordRun.*failed" supabase/functions/cron-automations/index.ts</automated>
    <manual>Confirm anyFailed is declared in executeActions, set to true in the catch block, returned in the result object, and used to set runStatus before recordRun is called.</manual>
  </verify>
  <done>
    - `executeActions()` returns `{ executed, anyFailed }` instead of bare array
    - When any action throws, `anyFailed` is `true`
    - `recordRun` is called with `"failed"` when `anyFailed` is true
    - `recordRun` is called with `"ok"` when all actions succeed
    - The `status: "ok" | "skipped" | "failed"` union in `recordRun` signature is preserved
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. Run: `grep -n "anyFailed\|isScheduleDue\|lastFiredAt" supabase/functions/cron-automations/index.ts` — should return matches for all three identifiers
2. Run: `grep -n "return true" supabase/functions/cron-automations/index.ts` — the old always-true shouldTriggerFire body should NOT appear unchanged
3. Run: `grep -c "\"ok\"" supabase/functions/cron-automations/index.ts` — line 135 should no longer hard-code "ok" for action results
4. Deno type-check (if available): `cd supabase/functions/cron-automations && deno check index.ts`
</verification>

<success_criteria>
- `isScheduleDue("daily", null)` returns true (never fired)
- `isScheduleDue("daily", new Date(Date.now() - 2 * 3600000).toISOString())` returns false (2 hours ago)
- `isScheduleDue("weekly", new Date(Date.now() - 8 * 86400000).toISOString())` returns true (8 days ago)
- An automation run where one action throws is recorded with `status = "failed"` in `automation_runs`
- An automation run where all actions succeed is recorded with `status = "ok"`
</success_criteria>

<output>
After completion, create `.planning/phases/03-background-jobs/03-01-SUMMARY.md`
</output>
